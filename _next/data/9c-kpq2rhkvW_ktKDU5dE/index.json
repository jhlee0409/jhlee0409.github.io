{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":2},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"AWS Amplify Next.js 동적 경로(Dynamic Routes) 설정하기","date":"2022-09-17","tags":["TIL","AWS","Amplify","Next.js","Dynamic Routes","동적 경로"],"draft":false,"summary":"Amplify로 배포된 Next.js 프로젝트 동적 경로 설정하기","mainCategory":"platform","subCategory":"AWS"},"content":"\n# 서론\n\n- `static`하게 생성된 `html`파일들을 `Amplify`로 배포할 시에는 `url`에 맞는 `html`파일을 보여준다.\n- 하지만 `동적`으로 설정한 경로 같은 경우 이벤트 리스너로 `Link`이동 시에는 정상 작동하지만, 새로고침하거나 직접 주소창에 `url`을 치고 들어오면 `404 에러`를 반환한다.\n- 그 이유는`static`하게 생성된 `동적 경로`로 만들어진 `html` 파일을 보면 `[id].html` 이런 형식으로 만들어져 있기 때문에 실제 주소창에 적혀있는 `url`에 맞는 `html`파일을 찾지 못하기 때문이다.\n- `Next.js`의 `SSG`를 담당하는 함수를 호출해서 생성하면 각각에 `id`에 맞게 `html`파일을 전부 만들어준다면 `동적 경로`를 따로 설정할 필요가 없다.\n- 허나 실질적으로 `id`가 수백, 수천 개에 달하는 게시물 같은 경우 모든 `html` 파일들을 만들어주는 것은 비효율적이다.\n- 그렇다면 `동적 경로`로 만들어진 `html`파일의 경우 어떤식으로 설정을 하면 될까?\n\n# 사용법\n\n## 1. Amplify 콘솔로 진입 후 설정할 프로젝트로 이동\n- 이후 `다시 쓰기 및 리디렉션`을 클릭한다.\n\n![Amplify 프로젝트 좌측 메뉴](/assets/posts/til/AWS/AWS-Amplify-Next.js-동적-경로(Dynamic-Routes)-설정하기/01.png)\n\n## 2. `다시 쓰기 및 리디렉션` 페이지로 이동\n- 여기서는 라우팅에 관련해서 설정한 목록들을 확인할 수 있다.\n- 이후 `편집`을 누른다.\n\n![다시 쓰기 및 리디렉션 페이지](/assets/posts/til/AWS/AWS-Amplify-Next.js-동적-경로(Dynamic-Routes)-설정하기/02.png)\n\n\n## 3. `다시 쓰기 및 리디렉션` 설정\n- 여기서 오늘 할 `동적 경로`를 설정할 것이다.\n- 이외에도 `200`, `301`, `302`, `404`등 다양한 `status`에 대해 설정이 가능하다.\n\n![다시 쓰기 및 리디렉션 설정 페이지](/assets/posts/til/AWS/AWS-Amplify-Next.js-동적-경로(Dynamic-Routes)-설정하기/03.png)\n\n### 설정법\n\n- `static`하게 생성된 동적 경로로 이루어진 `html`파일 이름을 `대상 주소`에 그리고 파라미터 값의 이름을 그대로 가져다가 `<>`로 바꿔준뒤 `.html`을 제거해서 `소스 주소`에 넣는다.\n- 형식은 `200`으로 설정해준다.\n- `소스 주소`가 실제로 주소창에 표기되는 형식이다.\n> e.g. `/theme/<id>`의 `소스 주소`의 경우 주소창에 표기될 때는 `/theme/primary`, `/theme/secondary`이런 식으로 매칭이 된다.\n\n| 소스 주소 | 대상 주소 | 형식 |\n| ---- | ---- | ----------- |\n| /theme/<id> | /theme/[id].html | 200(다시 쓰기) |\n| /theme/<id>/main.html | /theme/[id]/main.html | 200(다시 쓰기) |\n| /post/<categoryId>/<postId> | /post/[categorId]/[postId].html | 200(다시 쓰기) |\n\n- 위와 같은 형식으로 `다시 쓰기 및 리디렉션` 페이지에서 설정해주면 `동적경로`로 이루어진 페이지로 매칭된다.\n- 이후 `저장`버튼을 누르고 반영 메세지를 확인한 뒤 새로고침이나 직접 주소창에 입력해서 들어가도 정상적으로 `url`에 맞는 `html`을 보여주는 것을 확인할 수 있다.\n\n***\n\n### 참조\n\n- [Using redirects - AWS Amplify Hosting](https://docs.aws.amazon.com/amplify/latest/userguide/redirects.html)\n- [Amplify HostingでのNext.jsのDynamic Routesの設定](https://zenn.dev/nus3/articles/e3da1bdb3ef302962f07)\n\n***\n\n#### 피드백은 언제나 환영입니다.","path":"AWS Amplify Next.js 동적 경로(Dynamic Routes) 설정하기"},{"data":{"title":"[Typescript] tsconfig 절대경로 설정하기","date":"2022-09-15","tags":["TIL","Typescript","tsconfig.json","jsconfig.json","Absolute paths"],"draft":false,"summary":"tsconfig.json 설정을 통해 절대경로를 설정해보자","mainCategory":"tech","subCategory":"typescript"},"content":"\r\n# 서론\r\n- 특정 컴포넌트나 파일을 `import`할 시 경로의 `depth`가 깊어지면 깊어질수록 `import`하려는 파일의 위치에 따라 `상대경로`가 상당히 길어질 수 있다.\r\n```javascript\r\n// 극단적인 예\r\nimport deep from '../../../../../../../A/B/C/file.js';\r\n\r\n// 이런게 수없이 많다면?\r\nimport deep1 from '../../../../../../../A/B/C/file1.js';\r\nimport deep2 from '../../../../../../../A/B/C/file2.js';\r\nimport deep3 from '../../../../../../../A/B/C/file3.js';\r\nimport deep4 from '../../../../../../../A/B/C/file4.js';\r\nimport deep5 from '../../../../../../../A/B/C/file5.js';\r\n...\r\n...\r\nimport deep999 from '../../../../../../../A/B/C/file5.js';\r\n```\r\n- 이런 식으로 상대경로가 길어지면 `import`할 파일을 찾기위한 수고가 커질 뿐더라 가독성 면에서도 좋지 않다.\r\n- `tsconfig.json` or `jsconfig.json`의 설정을 통해 `절대경로`를 설정할 수 있다\r\n\r\n# tsconfig.json 이란?\r\n- `typscript`에 대한 설정을 할 수 있는 파일이며 `javascript`로 이루어진 레포지토리라면 `jsconfig.json`을 사용한다.\r\n- 해당 레포지토리가 `Typescript`를 사용하고 있다면 루트 디렉토리에 `tsconfig.json`이 존재해야며 `tsc`명령어를 통한 컴파일시 로드한다.\r\n- 컴파일러에 대한 옵션 설정과 더불어 다양한 기능을 제공한다.\r\n```json\r\n// tsconfig.json 의 예시\r\n{\r\n  \"compilerOptions\": {\r\n    ...\r\n  },\r\n  \"include\": [...],\r\n  \"exclude\": [...]\r\n}\r\n```\r\n\r\n## 절대경로 설정하기\r\n- `tsconifg.json`에서 `compilerOptions` 옵션의 `baseUrl`과 `paths`를 이용해서 `절대경로`를 설정한다.\r\n- `baseUrl`의 경우 `paths`를 설정하기 위해서는 반드시 설정해야하는 옵션이다.\r\n- `paths`의 경우 `key-value`쌍으로 이루어진 객체이며 절대경로를 정의하고자 하는 경로의 이름을 `key`에 입력하며 `baseUrl`을 기준으로 상대적인 경로를 `value`에 입력한다.\r\n- `paths`의 `key`에는 주로 `@`으로 시작을 하며 바로 다음으로 `/, _` 같은 특수문자를 넣는데 이유는 `@`로 시작하는 패키지가 종종 있기 떄문이다.\r\n```json\r\n// tsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\", // 이 경우는 tsconfig.json이 존재하는 루트 디렉토리를 기준으로 삼는다.\r\n    \"paths\": {\r\n      \"@_components/*\": [\"src/components/*\"],\r\n      \"@_apis/*\": [\"src/api/*\"],\r\n      \"@_types/*\": [\"src/types/*\"],\r\n      \"@_icons/*\": [\"public/assets/icons/*\"],\r\n      \"@_images/*\": [\"public/assets/images/*\"],\r\n      \"@_emojis/*\": [\"public/assets/emoji/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n- 위와 같은 `paths`를 지정한다면 실제로 루트 디렉토리를 기준으로한 구조는 다음과 같다\r\n```text\r\nRoot\r\n├─ public\r\n│   └─ assets\r\n│      ├─ icons\r\n│      ├─ images\r\n│      └─ emojis\r\n└─ src\r\n     ├─ components\r\n     ├─ api\r\n    └─ types\r\n```\r\n- 실제로 적용된 예시를 보자\r\n```typescript\r\nimport path1 from '@_components/home/main.tsx';\r\nimport path2 from '@_icons/sample.png';\r\nimport path2 from '@_apis/member'\r\n```\r\n- 특정 파일뿐만 아니라 모듈도 `절대경로`로 지정이 가능하다.\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n# 추가\r\n\r\n- 절대경로를 추가하는 `paths`가 늘어나면 따로 빼놓는 것도 가능하다.\r\n- `tsconfig.json`의 `extends`옵션을 이용한다.\r\n- 기본 `config` 파일을 읽어온 후 `extends`에 지정한 파일에 의해 오버라이딩(overridden) 된다.\r\n- `include`나 `exclude`에 정의한 파일의 경우 기본 `config` 파일을 덮어쓴다.(overwrite)\r\n- `extends` 옵션은 스트링값으로만 받는다.\r\n- 여러 설정 파일을 `extend`하고 싶다면 줄줄이 이어받는 구조를 만들어야한다.\r\n    ```json\r\n    // tsconfig.a.json\r\n    {\r\n      \"compilerOptions\": {\r\n        ...\r\n      },\r\n    }\r\n    ```\r\n  ```json\r\n  // tsconfig.b.json\r\n  {\r\n    \"compilerOptions\": {\r\n      ...\r\n    },\r\n    \"extends\": \"./tsconfig.a.json\"\r\n  }\r\n    ```\r\n  ```json\r\n  // tsconfig.json\r\n  {\r\n    \"compilerOptions\": {\r\n      ...\r\n    },\r\n    \"extends\": \"./tsconfig.b.json\"\r\n  }\r\n    ```\r\n\r\n## 사용법\r\n- 위에 설정한 파일을 따로 만들어 저장해둔다.\r\n- 파일명은 어떤식으로 지어도 상관없으며, 어느 디렉토리에 속해도 된다. `json`형식이면 된다.\r\n- 아래의 경우 `tsconfig.path.json`을 루트 디렉토리에 만든다.\r\n\r\n```json\r\n// tsconfig.paths.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"@_components/*\": [\"src/components/*\"],\r\n      \"@_apis/*\": [\"src/api/*\"],\r\n      \"@_types/*\": [\"src/types/*\"],\r\n      \"@_icons/*\": [\"public/assets/icons/*\"],\r\n      \"@_images/*\": [\"public/assets/images/*\"],\r\n      \"@_emojis/*\": [\"public/assets/emoji/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n- `tsconfig.json`에 `extends`옵션을 추가한 뒤 확장하고자하는 `json`을 파일을 `tsconifg.json`을 기준으로한` 상대경로`로 입력해준다.\r\n```json\r\n// tsconifg.json\r\n{\r\n  \"compilerOptions\": {\r\n    ...\r\n  },\r\n  \"extends\": \"./tsconfig.paths.json\"\r\n}\r\n```\r\n\r\n\r\n\r\n#\r\n\r\n### 참조\r\n- [TSConfig Reference](https://www.typescriptlang.org/tsconfig)\r\n- [Documentation - What is a tsconfig.json](https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html)\r\n\r\n#\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"[Typescript] tsconfig 절대경로 설정하기"},{"data":{"title":"[Next.js] Page Extensions","date":"2022-09-13","tags":["TIL","Next.js","next.config.js","pageExtensions"],"draft":false,"summary":"next.config.js 파일의 page extensions 옵션을 커스텀해보자","mainCategory":"tech","subCategory":"Next.js"},"content":"\r\n\r\n# 서론\r\n\r\n- 작업을 하다보면 임시적으로 접근을 제한하여야 하는 파일들이 있을 수 있다.\r\n- 폴더 최상위에 존재하는 `next.config.js`의 `pageExtensions`을 통해 `page`디렉토리 내 파일들을 대상으로 확장자명에 따라서 파일의 접근을 막을 수 있다.\r\n- `pageExtensions`의 규칙을 따르지 않은 파일에 대해서는 접근시 `404 (Not Found)`에러를 반환한다.\r\n\r\n#### default pageExtensions\r\n```jsx\r\n// next.config.js\r\nmodule.exports = {\r\n  pageExtensions: ['jsx', 'js', 'tsx', 'ts'],\r\n}\r\n```\r\n\r\n\r\n# 사용법\r\n> e.g. `page.` prefix를 붙일 시\r\n```jsx\r\nmodule.exports = {\r\n  pageExtensions: ['page.tsx', 'page.ts', 'page.jsx', 'page.js'],\r\n}\r\n```\r\n- 위와 같이 확장자명을 설정한다면 `pages` 디렉토리 내에 포함하고자 하는 파일의 확장자명에 전부 `page.`을 붙여야한다.\r\n- `_document`, `_app` 그리고 `pages/api`내에 있는 파일에도 동일하게 적용시켜 주어야한다.\r\n\r\n## 현재 디렉토리 구조\r\n```text\r\n└─ pages\r\n    ├─ _app.page.tsx\r\n    ├─ _document.page.tsx\r\n    ├─ home\r\n    │  └─ main.page.tsx\r\n    │  └─ exclude.tsx  // 제외\r\n    └─ main.page.tsx\r\n```\r\n#\r\n### 빌드시\r\n```text\r\nPage\r\n┌ ● /\r\n├   /_app\r\n├ ○ /404\r\n└ ● /home/main\r\n```\r\n#\r\n### `exclude.page.tsx`로 확장자명 변경후 재빌드시\r\n```text\r\nPage\r\n┌ ● /\r\n├   /_app\r\n├ ○ /404\r\n├ ● /home/exclude\r\n└ ● /home/main\r\n```\r\n\r\n\r\n#\r\n\r\n### 참고\r\n- [Custom Page Extensions](https://nextjs.org/docs/api-reference/next.config.js/custom-page-extensions#including-non-page-files-in-the-pages-directory)\r\n\r\n#\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"[Next.js] Page Extensions"},{"data":{"title":"[Solidity] 04. Solidity 용어","date":"2022-09-12","tags":["TIL","Solidity","Address","Mapping","Variables","Modifier","Constructor"],"draft":false,"summary":"Solidity에서 주로 사용되는 용어를 알아보자","mainCategory":"blockchain","subCategory":"solidity"},"content":"\n## Address 주소\n\n- `20 byte` 형식의 변수 타입\n- 주소로 선언한 변수는 이더리움 주소가 되도록 설정한다.\n\n```solidity\naddress wallet\naddress payable[] wallets\n```\n\n## Mapping 매핑\n\n- 값에 대한 참조를 가진다.\n- 키-값 쌍으로 구성된 해시 테이블을 생성 (키-값을 쌍으로 저장)\n- 각 키를 추적할 수 있도록 테이블을 만든다.\n\n```solidity\nmapping(_KeyType => _ValueType)\n\n// 주소를 정수에 매핑\nmapping(address => uint) public balances;\n```\n\n![출처: 참조 링크로!, [Mappings in Solidity Explained in Under Two Minutes]](https://miro.medium.com/max/429/1*H415ldFYnS2aRTx1YIQiKg.png)\n\n\n## Scope of Variables 변수의 범위\n\n- `State Variables` (상태 변수)\n    - 값이 계약 저장소(contract storage)에 영구적으로 저장되는 변수입니다.\n    - 계약 저장소로 가도록 선언된 변수 = 상태 변수\n    - 모든 함수와 계약에서 접근 가능\n    - 변수로 선언된 것\n- `Local Variables` (지역 변수)\n    - 해당 함수 안에서 선언된 변수\n    - 선언된 함수 안에서만 접근 가능\n\n```solidity\ncontract TestStroage {\n\tuint balance;  // state variable\n\n\tfunction set(uint x) public {\n\t\tstring value = 'data'; // local variable\n\t}\n}\n```\n\n- Global Variables (전역 변수)\n    - `global namespace(전역 네임스페이스)`에 존재하는 특수 변수\n    - 블록체인에 존재하는 정보를 가져올 때 이 변수를 사용\n\n![전역 변수들](/assets/posts/blockchain/solidity/Solidity-04-Solidity-용어/01.png)\n\n## Modifier 제어자\n\n- 함수의 실행을 제어하거나 수정할 수 있게 해준다.\n\n```solidity\ncontract Test {\n\taddress testAddress;\n\tconstructor() {\n\t\ttestAddress = msg.sender;\n\t}\n\t\n\t// testAddress 와 mag.sender가 일치하는 경우에만 함수 실행\n    // 다양한 조건들을 걸 수 있다.\n\tmodifier onlyOwner {\n\t\tif (msg.sender == testrAddress) {\n\t\t\t_; // keep going!\n\t\t}\n\t}\n\t// 사용법\n    // onlyOwner의 조건을 만족하는 경우에만 함수 실행\n\tfunction testFn() public onlyOwner {\n\t\t// ...\n\t}\n}\n```\n\n## Constructor 생성자\n\n- `constructor`는 `constructor` 키워드를 사용하여 선언된 함수이다.\n- 계약 생성 시에만 실행됩니다.\n- `constructor`를 작성하지 않는 경우 `contract`는 기본 생성자로 간주됩니다.\n\n```solidity\ncontract Test {\n\taddress testAddress;\n\n\tconstructor() {\n\t\ttestAddress = msg.sender;\n\t}\n}\n```\n\n#\n\n### 참조\n\n- [Solidity - Variables](https://www.tutorialspoint.com/solidity/solidity_variables.htm)\n- [Mappings in Solidity Explained in Under Two Minutes](https://medium.com/upstate-interactive/mappings-in-solidity-explained-in-under-two-minutes-ecba88aff96e)\n\n#\n\n#### 피드백은 언제나 환영입니다.","path":"[Solidity] 04. Solidity 용어"},{"data":{"title":"AbortController 파헤치기","date":"2022-09-09","tags":["TIL","Javascript","AbortController","signal","abort()"],"draft":false,"summary":"AbortController 통해 API 요청을 취소해보자","mainCategory":"tech","subCategory":"javascript"},"content":"\r\n# AbortController란?\r\n\r\n- 하나 이상의 웹 요청을 취소할 수 있게 해준다.\r\n- `new` 키워드를 이용해 `AbortController` 객체 인스턴스를 생성한다.\r\n\r\n\r\n# AbortController 구성요소\r\n\r\n- `AbortController.signal` : DOM 요청과 통신하기 위한 객체\r\n- `AbortController.abort()`: DOM 요청이 완료되기 전에 취소한다.\r\n    - 호출시 `catch`문으로 바로 넘어간다\r\n    - `abort()` 통해 취소하면 `network status`에 상태코드가 아닌 `canceled`라고 뜬다.\r\n    - 이벤트리스너를 통해서 `abort()` 호출 가능\r\n## `abort()` 호출 시점에 따른 차이\r\n\r\n1. API 요청 전\r\n    - occur error : `AbortError: Failed to execute 'fetch' on 'Window': The user aborted a request`.\r\n2. API 요청 성공 시점\r\n    - `abort()` 메소드 무시하고 정상 진행\r\n3. API 요청 끝난 후\r\n    - occur error : `AbortError: The user aborted a request.`\r\n4. `finally()` 메소드 호출 시점\r\n    - `abort()` 메소드 무시하고 정상 진행\r\n\r\n# 사용법\r\n- API 호출 시 `option`에 `signal`객체 추가\r\n- API 요청 끝난 후 `abort()` 호출\r\n\r\n## fetch 사용시\r\n```javascript\r\nconst controller = new AbortController();\r\n\r\nfetch('/foo/bar', {\r\n    signal: controller.signal\r\n })\r\n  .then((res) => res.json())\r\n  .then((data) => {\r\n    console.log(data);\r\n  })\r\n  .catch((err) => console.log(\"err: \" + err))\r\n    // log => \"err: AbortError: The user aborted a request.\"\r\n\r\n// 요청 취소\r\ncontroller.abort();\r\n```\r\n\r\n## axios 사용시\r\n```javascript\r\nconst controller = new AbortController();\r\n\r\naxios.get('/foo/bar', {\r\n   signal: controller.signal\r\n}).then((res) => {\r\n   //...\r\n})\r\n.catch((err) => console.log(\"err: \" + err));\r\n    // log => \"err: AbortError: The user aborted a request.\"\r\n\r\n// 요청 취소\r\ncontroller.abort()\r\n```\r\n\r\n#\r\n### 참조\r\n\r\n- [AbortController](https://developer.mozilla.org/ko/docs/Web/API/AbortController)\r\n- [Cancellation | Axios Docs](https://axios-http.com/docs/cancellation)\r\n#\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"AbortController 파헤치기"}]},"__N_SSG":true}