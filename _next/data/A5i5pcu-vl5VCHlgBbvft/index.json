{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":10},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"Helper 메소드 재귀 패턴","date":"2022-10-02","tags":["TIL","Udemy","Algorithm","헬퍼 메소드","Helper Method"],"draft":false,"summary":"헬퍼 메소드 재귀 패턴을 이용해서 직관적인 재귀 함수를 구현해보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\n&nbsp;\n\n# Helper 메소드 재귀 패턴\n\n- 재귀 함수를 실행했을 때 특정 값들을 담은 `배열`을 반환해야하는 경우, 순수 재귀 함수만으로는 까다롭다. 이유는 재귀 함수를 호출 할떄마다\n재귀 함수 내의 변수는 초기값으로 리셋되기 마련인데, 이 변수의 값들을 재귀를 돌때마다 이전 값을 유지하면서 반환하는 작업을 따로 구현해주어야 하기 떄문이다.\n그렇기 때문에 재귀 함수를 감싸는 함수를 하나 만들어서 그곳에 결과 변수를 하나 두고 재귀 함수를 통해 얻은 특정 값을 담는다.\n- Helper 메소드 재귀를 쓰는 것이 더 직관적이다.\n\n&nbsp;\n\n## Helper 메소드 재귀 패턴으로 구현했을 때\n\n- 어떤 결과를 컴파일하 때 흔히 사용되는 패턴이다.\n- 재귀 함수를 감싸는 재귀로 구현되지 않은 함수를 사용하는 패턴이다.\n- `collectOddValues()` : 재귀로 구현되지 않은 함수\n- `helper()` : 재귀 함수\n- `result`를 `helper`함수 안에 정의하게 되면 함수가 호출될 떄마다 빈배열로 리셋되기 때문에 때문에 밖으로 뺸다.\n\n```jsx\nconst collectOddValues = (arr) => {\n    let result = [];\n    const helper = (helperInput) => {\n        if (helperInput.length === 0) {\n            return;\n        }\n        if (helperInput[0] % 2 !== 0) {\n            result.push(helperInput[0]);\n        }\n        helper(helperInput.slice(1));\n    };\n    helper(arr);\n    return result;\n};\n\ncollectOddValues([1, 2, 3, 4]);\n```\n\n&nbsp;\n\n## 순수 재귀 함수로 구현했을 때\n\n```jsx\nconst collectOddValues = (arr) => {\n    let newArr = [];\n\n    if(arr.length === 0) {\n        return newArr;\n    }\n\n    if(arr[0] % 2 !== 0) {\n        newArr.push(arr[0]);\n    }\n\n    newArr = newArr.concat(collectionOddvalues(arr.slice(1)));\n\n    return newArr;\n};\n\n// 순수 재귀 함수의 콜 스택 과정\ncollectOddValues([1, 2, 3, 4, 5]); // => [1, 3, 5]\n    [1].concat(collectOddValues([2,3,4,5])) // => [3, 5]\n                    [ ].concat(collectOddValues([3,4,5])) // => [3, 5]\n                                    [3].concat(collectOddValues([4,5])) // => [5]\n                                                    [ ].concat(collectOddValues([5])) // => [5]\n                                                                    [5].concat(collectOddValues([ ])) // => []\n                                                                                    [ ]\n```\n\n&nbsp;\n\n## Helper 메소드 없이 순수 재귀 함수를 구현했을 때 사용하는 유용한 메소드\n\n- 배열을 사용하는 경우\n    - 배열을 복사하는 `slice, spread 연산자, concat` 같은 메소드를 사용할 수 있다. 그러면 배열을 변경할 필요가 없다.\n- 문자열을 사용하는 경우\n    - 문자열은 불변하기(변경할 수 없기) 때문에 `slice, substr, substring` 메소드들을 이용해서 문자열의 복사본을 만든다.\n- 객체를 사용하는 경우\n    - 객체의 경우 `Object.assign, spread 연산자`를 이용해서 복사본을 만들어 구현한다.\n---\n\n#### 피드백은 언제나 환영입니다.","path":"Helper 메소드 재귀 패턴"},{"data":{"title":"팩토리얼(Factorial) 구현하기","date":"2022-09-30","tags":["TIL","Udemy","Algorithm","팩토리얼","Factorial"],"draft":false,"summary":"반복문과 재귀 함수로 팩토리얼을 구현해보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\n&nbsp;\n\n# 팩토리얼(Factorial)\n\n- 재귀 함수를 이용한 가장 흔한 패턴은 팩토리얼을 구현하는 것이다.\n- 팩토리얼은 `n!`이며 n이 양의 정수일 때 1부터 n까지 그 수들을 모두 곱하는 것이다.  `0!의 경우 1이다.`\n- 단순 반복문과 재귀 함수로 팩토리얼을 구현해보자.\n\n\n# 1. 반복문으로  팩토리얼 구현하기\n\n```jsx\nconst factorial = (num) => {\n    let result = 1;\n    for(let i = 1; i <= num; i++) {\n        result *= i;\n    }\n    return result\n}\n\nfactorial(5) // 120\n```\n\n# 재귀 함수로 팩토리얼 구현하기\n\n- 해당 로직의 이해가 필요하다면 [이전 포스팅](https://jhlee0409.github.io/tech-Data_Structure_&_Algorithms/article/%EC%9E%AC%EA%B7%80-%ED%95%A8%EC%88%98-%EC%98%88%EC%A0%9C)에서 두 번째 재귀 함수 구현 부분을 보면 참고하면 된다.\n\n```jsx\nconst factorial = (num) => {\n    // 0!과 1!은 1이기 때문에 종료조건을 아래와 같이 세팅\n    // 안걸면 음수까지 가면서 영원히 계산된다.\n    if (num <= 1) return 1;\n    return num * factorial(num-1);\n  }\n\nfactorial(5) // 120\n```\n\n---\n\n#### 피드백은 언제나 환영입니다.","path":"팩토리얼(Factorial) 구현하기"},{"data":{"title":"재귀 함수 예제","date":"2022-09-29","tags":["TIL","Udemy","Algorithm","재귀 함수 예제","Recursive Function","Recursion"],"draft":false,"summary":"재귀 함수 예제 2가지를 살펴보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 재귀 함수\r\n\r\n- 기본적인 개념은 동일한 함수를 계속 호출하면서, 하나의 함수가 자기 자신을 재귀적으로 호출하게 하는 것이다\r\n- 어떤 재귀 함수든 반드시 갖춰야 하는 두 가지 요소가 있다.\r\n  1. `종료 조건`(재귀가 멈추는 시점)이 있어야 한다.\r\n  2. `다른 입력값`을 받아야한다. (재귀 함수를 호출할 때 매번 다른 데이터가 들어와야한다.)\r\n\r\n# 첫번째 재귀 함수\r\n\r\n- `countDown(0)` => 종료 조건 `if문`에서 걸려 종료된다\r\n- 종료 조건에서 `return` 하지않으면 콘솔만 찍히고 계속 진행된다.\r\n    - `return`을 꼭하거나 `else문`을 써서 종료시켜야한다.\r\n```jsx\r\n  const countDown = (num) => {\r\n    if (num <= 0) { // 종료 조건\r\n      console.log(\"All done!\");\r\n      // return 하지않으면 콘솔만 찍히고 재귀 함수는 계속 진행된다.\r\n      return;\r\n      // 아니면 else 문을 써야한다.\r\n    }\r\n    console.log(num);\r\n    num--;\r\n    countDown(num);\r\n  };\r\n\r\ncountDown(10)  // 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 3 -> 1 -> All done!\r\n```\r\n\r\n# 두번째 재귀 함수\r\n\r\n- 첫번째 재귀 함수와 다른 점은 재귀 함수가 계속해서 `return` 한다는 것이다\r\n- 여기서 이전 포스팅 내용인 `콜 스택`의 개념을 알면 이해하기 쉽다\r\n    1. `sumRange(3)`함수를 가정 먼저 호출하게 되면 1층에 쌓인다.\r\n    2. `sumRange(3)`함수 내의 `sumRange(2)`함수를 호출하게 되고 `sumRange(3)`은 `return`한게 없기 때문에 1층에 그대로 있고 위에 얹혀서 2층에 쌓인다.\r\n    3. `sumRange(2)`함수 내의 `sumRange(1)`함수를 호출하게 되고 `sumRange(2)`은 `return`한게 없기 때문에 2층에 그대로 있고 위에 얹혀서 3층에 쌓인다.\r\n    4. `sumRange(1)`함수 호출 시 `if문(종료 조건)`에 걸려 `1`을 반환하고 콜 스택에서 제거된다.\r\n    5. `sumRange(2)`함수는 `sumRange(1)`에서 반환된 값 `1`과 `num`값인 `2`를 더한 값인 `3 (= 2 + sumRange(1))`을 반환하고 콜 스택에서 제거된다.\r\n    6. `sumRange(3)`함수는 `sumRange(2)`에서 반환된 값 `3`과 `num`값인 `3`를 더한 값인 `6 (= 3 + sumRange(2))`을 반환하고 콜 스택에서 제거된다.\r\n    7. 결과적으로 `6`을 반환한다.\r\n\r\n```jsx\r\n  const sumRange = (num) => {\r\n    if (num === 1) return 1; // 종료 조건\r\n    return num + sumRange(num - 1);\r\n  };\r\n\r\n// 콜 스택 과정\r\nsumRange(3) // 6\r\n    return 3 + sumRange(2) // 3 + 3\r\n                    return 2 + sumRange(1) // 2 + 1\r\n                                    return 1\r\n```\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"재귀 함수 예제"},{"data":{"title":"콜 스택 (Call Stack)","date":"2022-09-29","tags":["TIL","Udemy","콜 스택","호출 스택","Call Stack"],"draft":false,"summary":"콜 스택에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 콜 스택 (Call Stack)\r\n\r\n- 대부분의 프로그래밍 언어에서는 함수 호출을 관리하는 데이터 구조가 있다.\r\n- 자바스크립트에서 함수 호출을 관리하는 것이 `콜 스택`이다.\r\n- `콜 스택`은 자바스크립트의 보이지 않는 곳에서 작동하는 정적 데이터 구조이다.\r\n- 함수를 호출하게 되면 `콜 스택`에 스택이 쌓이게 되고 가장 위에 쌓인 함수부터 처리후 `콜 스택`에서 제거된다.\r\n- `콜 스택`에서 제거되는 조건은 함수가 종료되거나 `return`을 하게 되었을 떄이다.\r\n\r\n&nbsp;\r\n\r\n# 콜 스택이 동작하는 과정\r\n\r\n- 콜 스택의 과정을 보여주기 위해 작성한 코드 이다.\r\n- `trigger` 함수에 `breakpoint`를 걸고 우측의 `콜 스택` 블럭을 통해 진행 과정을 알아보자\r\n\r\n![trigger 함수 호출](/assets/posts/til/DS&Al/콜스택/01.png)\r\n\r\n&nbsp;\r\n\r\n## 1. trigger 함수 호출\r\n\r\n- 먼저 `trigger` 함수가 호출되면 콜 스택에 쌓인다.\r\n\r\n![trigger 함수를 콜 스택에 추가](/assets/posts/til/DS&Al/콜스택/02.png)\r\n\r\n&nbsp;\r\n\r\n## 2. firstFn 함수 호출\r\n\r\n- 이전에 호출된 `trigger` 함수에서 `firstFn` 함수를 호출\r\n- 콜 스택에 `firstFn` 함수가 쌓이게 된다.\r\n- 아직 `trigger` 함수는 끝나지 않은 상태임과 동시에 가장 먼저 호출된 함수이기 때문에 가장 아래에 위치해 있다.\r\n\r\n![firstFn 함수를 콜 스택에 추가](/assets/posts/til/DS&Al/콜스택/03.png)\r\n\r\n- 이후 `firstFn` 함수는 `return` 을 한다.\r\n\r\n![firstFn 함수에서 값을 return](/assets/posts/til/DS&Al/콜스택/04.png)\r\n\r\n- `return`을 했으니 콜 스택에서 `firstFn` 함수는 제거 된다.\r\n\r\n![firstFn 함수를 콜 스택에서 제거](/assets/posts/til/DS&Al/콜스택/05.png)\r\n\r\n&nbsp;\r\n\r\n## 3. secondFn 함수 호출\r\n\r\n- `trigger` 함수에서 `firstFn` 함수가 호출/제거 된 후, `secondFn` 함수를 호출하게되면 콜 스택에 쌓인다.\r\n- 이 때도 아직 `trigger` 함수는 끝나지 않았기 때문에 아직 콜 스택에 남아있다.\r\n\r\n![secondFn 함수를 콜 스택에 추가](/assets/posts/til/DS&Al/콜스택/06.png)\r\n\r\n\r\n- 이 후 `secondFn` 함수에서 `generateNumber` 함수를 호출하면 콜스택에 쌓인다.\r\n- 이 때 아직 `secondFn` 함수는 끝나지 않았기 때문에 콜스택에 남아있다.\r\n> 사진에서 generateNumnber -> generateNumber 로 오타 정정\r\n\r\n![secondFn 함수에서 값을 return](/assets/posts/til/DS&Al/콜스택/07.png)\r\n\r\n\r\n- `generateNumber` 함수가 `1`이란 값을 `return` 했기 때문에 종료 후 콜 스택에서 제거된다.\r\n\r\n![secondFn 함수를 콜 스택에서 제거](/assets/posts/til/DS&Al/콜스택/08.png)\r\n\r\n\r\n- 이후 secondFn 함수는 `generateNumber` 함수에서 `return`된 값 `1`을 가지고 `return`을 하게 된다.\r\n- 이렇게 `secondFn` 함수도 `return`한 후 콜 스택에서 제거된다.\r\n\r\n&nbsp;\r\n\r\n## 4. trigger 함수 종료\r\n\r\n- `secondFn` 함수도 종료/제거가 되면서 `trigger`함수는 마지막 남은 `console.log`를 띄운다.\r\n\r\n![trigger 함수에서 condole.log를 띄움](/assets/posts/til/DS&Al/콜스택/09.png)\r\n\r\n\r\n- `console.log`를 띄운 후 `trigger` 함수도 종료가 된다.\r\n\r\n![trigger 함수에서 띄운 log](/assets/posts/til/DS&Al/콜스택/10.png)\r\n\r\n![trigger 함수를 콜 스택에서 제거](/assets/posts/til/DS&Al/콜스택/11.png)\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"콜 스택 (Call Stack)"},{"data":{"title":"분할과 정복 패턴 (Divide and Conquer Pattern)","date":"2022-09-27","tags":["TIL","Udemy","Algorithm","분할과 정복 패턴","Divide and Conquer Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 분할과 정복 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 분할과 정복 패턴 (Divide and Conquer Pattern)\r\n\r\n- 주로 배열이나 문자열 같은 큰 규모의 데이터셋을 처리한다.\r\n- 이진 탐색이나 병합 정렬, 퀵 정렬 등에 사용되는 패턴이다.\r\n- 값을 찾기 위해 배열의 왼쪽에서 시작하여 오른쪽 끝까지 이동하는 것이 아닌 배열을 작은 조각으로 `세분`하여 각 조각들을 `어디로 이동`시킬지 결정하는 작업부터 시작한다.\r\n- 즉, 큰 데이터 덩어리를 작은 조각으로 나누는 거다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 정수로 이루어진 정렬된 배열과 찾으려는 값이 주어지면 배열에서 해당 값이 있는 인덱스(위치)를 반환하는 search라는 함수를 작성해라. 값을 찾을 수 없으면 -1을 반환한다.\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n)`\r\n- 선형 탐색\r\n- `arr`가 주어진다면 최대 `arr`의 길이만큼 반복해야 한다.\r\n\r\n```js\r\nconst search = (arr, val) => {\r\n\tfor(let i = 0; i < arr.length; i++) {\r\n\t\tif(arr[i] === val) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nsearch([1,2,3,4,5,6], 4) // 3\r\n```\r\n\r\n## 분할과 정복 패턴\r\n\r\n- 시간 복잡도 : `Log(n)`\r\n- 이진 탐색\r\n- 배열의 중간 값을 찾고나면 넘겨진 `val`이 속하는 배열을 골라 다시 중간 값을 찾고 `val`이 속한 배열을 골라서 `val`의 위치를 찾아낼 때까지 반복하는 작업\r\n\r\n```js\r\nconst search = (arr, val) => {\r\n  let min = 0;\r\n  let max = arr.length - 1;\r\n\r\n  while (min <= max) {\r\n\t\t// 배열의 중간 인덱스 (소수점 버림)\r\n    let middle = Math.floor((min + max) / 2);\r\n\r\n\t\t// 중간 인덱스의 값이 찾으려는 값보다 작으면\r\n\t\t// 찾으려는 값은 중간 인덱스의 값보다 큰 쪽에 속해 있다.\r\n\t\t// 증간 인덱스 보다 낮은 인덱스의 값들은 필요가 없으므로 min 값 갱신\r\n\t\t// e.g. 중간 인덱스의 값 = 3 / val = 4\r\n\t\t// 3이 4보다 작으니 3보다 작은 값들은 필요가 없다.\r\n    if (arr[middle] < val) {\r\n      min = middle + 1;\r\n    } else if (arr[middle] > val) {\r\n\t\t// 중간 인덱스의 값이 찾으려는 값보다 크면\r\n\t\t// 찾으려는 값은 중간 인덱스의 값보다 작은 쪽에 속해 있다.\r\n\t\t// 증간 인덱스 보다 큰 인덱스의 값들은 필요가 없으므로 max 값 갱신\r\n\t\t// e.g. 중간 인덱스의 값 = 7 / val = 4\r\n\t\t// 7이 4보다 크니 7보다 큰 값들은 필요가 없다.\r\n      max = middle - 1;\r\n    } else {\r\n        // 중간 인덱스의 값이 찾으려는 값과 같으면 바로 return\r\n        // e.g. 중간 인덱스의 값 = 4 / val = 4\r\n        // 중간 인덱스의 값이 찾으려는 값과 같으므로 위치 바로 return\r\n      return middle;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nsearch([1,2,3,4,5,6], 4) // 3\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"분할과 정복 패턴 (Divide and Conquer Pattern)"}]},"__N_SSG":true}