{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":14},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"정렬 알고리즘 (Sort Algorithm)","date":"2022-10-12","tags":["TIL","Udemy","Algorithm","정렬 알고리즘","Sort Algorithm"],"draft":false,"summary":"정렬 알고리즘과 JS의 배열 내장 메소드인 sort에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\n&nbsp;\n\n# 정렬이란?\n\n- 정렬은 간단히 배열과 같은 컬렉션(collection)의 항목을 재배열하는 과정을 말한다.\n- 배열, 목록, 트리와 같은 다른 데이터 구조도 정렬 가능하다.\n\n    > e.g. 숫자를 오름차순, 내림차순으로 정렬하기\n    >\n\n    > e.g. 문자를 알파벳순, ㄱㄴㄷ순으로 정렬하기\n    >\n\n    > e.g. 개봉 연도 또는 수익 … 을 기준으로 영화 정렬하기\n    >\n\n- [접근 방식에 따른 정렬 알고리즘 YOUTUBE 영상](https://youtu.be/kPRA0W1kECg)\n\n&nbsp;\n\n# 왜 정렬을 배우는 게 필요한가?\n\n- 정렬은 프로그래밍을 함에 있어서 흔히 접하기 때문에 동작 방식을 아는 게 좋다.\n    - 각 언어의 내장된 정렬 메소드를 쓸 때 동작 방식을 알아야 어느 상황 때 어느 메소드를 쓰는 게 좋은지 판단이 가능하다.\n- 다양한 방식의 정렬이 있고 각각 장단점이 있다.\n- 객관적으로 빠른 정렬이 있는 반면, 특정 상황에서 뛰어난 성능을 보여주는 정렬도 있다.\n- [Sorting Algorithms Animations](https://www.toptal.com/developers/sorting-algorithms)에서 어느 상황 때 어느 정렬 알고리즘이 좋은지 시각적 잘 보여준다.\n\n&nbsp;\n\n# Javascript의 배열 내장 메소드인 Array.sort()\n\n- `sort`메소드는 의도한 상황대로 정상적으로 작동하지 않을 때가 있다.\n- 기본적인 `sort`의 동작 방식은 숫자의 순서를 이해하지 못한다.\n- 왜 이해하지 못할까? [MDN Array.prototype.sort()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)를 보면 다음과 같은 이유 때문이다.\n    > 기본 정렬 순서는 문자열의 유니코드 코드 포인트를 따릅니다.\n- 그렇기에 숫자를 의도한 대로 정렬하기 위해서는 추가적인 로직 작성이 필요하다.\n\n```jsx\n// 추가 로직 작성 전\n\n// 오름차순으로 정렬하고자 할 때\n[2, 12, 5, 10].sort(); \n\n// 원하는 결과\n[2, 5, 10, 12]\n\n// 실제 결과\n[10, 12, 2, 5]\n```\n\n&nbsp;\n\n## 추가적인 작업\n\n- `sort()`는 인자로 `선택적 비교 함수(optional comparator function)`를 받을 수 있다.\n- `선택적 비교 함수`를 통해 우리가 원하는 정렬 방식을 전달할 수 있다.\n- `선택적 비교 함수`는 `A와 B`를 비교하고 반환되는 값을 기반으로 정렬한다.\n    - 만약 `음수`를 반환하면 `A는 B보다 앞에 정렬`된다.\n    - 만약 `양수`를 반환하면 `A는 B보다 뒤에 정렬`된다.\n    - 만약 `0`을 반환하면 `A와B는 같은 값이기 때문에 변화는 없다.`\n\n```jsx\n// 오름차순으로 정렬하고자 할 때\n[2, 12, 5, 10].sort((a,b) => {\n\treturn a - b;\n});\n\n// 음수 이기에 2는 12 앞에 정렬\n[2, 12] => 2 - 12 = -10  // [2, 12]\n\n// 양수 이기에 12는 5 뒤에 정렬\n[12, 5] => 12 - 5 = 7  // [2, 5, 12]\n\n// 양수 이기에 12는 10 뒤에 정렬\n[12, 10] => 12 - 10 = 2 // [2, 5, 10, 12]\n\n\n// result\n[2, 5, 10, 12]\n\n```\n\n&nbsp;\n\n- 문자열의 경우에도 어떤 비교함수를 작성하느냐에 따라 정렬 방식을 다양하게 할 수 있다\n\n> e.g. 문자의 길이를 기준으로 정렬하는 경우\n\n```jsx\n[\"Apple\", \"Pear\", \"Strawberry\", \"Cheery\"].sort((a,b)=> {\n\t// 반환되는 값은 0, 음수, 양수\n\treturn a.length - b.length; \n})\n\n// 양수 이기에 Apple은 Pear 뒤에 정렬\n['Apple', 'Pear'] => 5 - 4 = 1 // ['Pear', 'Apple']\n\n// 음수 이기에 Apple은 Strawberry 앞에 정렬\n['Apple', 'Strawberry'] => 5 - 10 = -4  // ['Pear', 'Apple', 'Strawberry']\n\n//양수 이기에 Strawberry는 Cherry 뒤에 정렬\n[\"Strawberry\", \"Cheery\"] => 10 - 6 = 4 // ['Pear', 'Apple', 'Cheery', 'Strawberry']\n\n\n// result\n['Pear', 'Apple', 'Cheery', 'Strawberry']\n```","path":"정렬 알고리즘 (Sort Algorithm)"},{"data":{"title":"나이브 문자열 검색 (Naive String Search)","date":"2022-10-09","tags":["TIL","Udemy","Algorithm","나이브 문자열 검색","Naive String Search"],"draft":false,"summary":"나이브 문자열 검색에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n\r\n# 나이브 문자열 검색 (Naive String Search)\r\n\r\n- 긴 문자열에서 부분 문자열을 검색하는 것과 관련이 있다.\r\n- 긴 문자열에서 짧은 문자열이 등장하는 횟수를 세야하는 상황에서 쓰인다.\r\n- 간단한 접근법 중 하나는 문자 하나씩 확인하는 것이다.\r\n\r\n&nbsp;\r\n\r\n# 나이브 문자열 검색의 의사코드 (Pseudocode)\r\n\r\n- 긴 문자열 1개와 짧은 문자열(찾으려는 문자열) 1개를 인자로 받는 함수를 작성한다.\r\n- 긴 문자열의 각 문자를 반복하는 루프를 작성하고 그 안에 짧은 문자열을 반복하는 루프도 하나 작성한다.\r\n- 문자가 일치하지 않으면 내부 루프를 벗어난다. (루프를 멈춘다)\r\n- 문자가 일치하면 계속 진행한다.\r\n- 만약 내부 루프를 완료하고 일치하는 문자열을 찾았으면 `count`를 증가시키고 마지막에 그 `count`를 반환한다.\r\n- 일치하는 문자열이 하나도 없으면 `0` 반환한다.\r\n- 긴 문자열을 반복하는 루프를 만드는 데, 그 루프 안에는 짧은 문자열을 반복하는 중첩(nested loop)가 있다.\r\n- 짧은 문자열의 끝에 도달했는데 아직 루프에서 벗어나지 못했으면 `count`를 `1`을 더한다.\r\n- 루프를 벗어나지 못했다는 뜻은 일치하는 짧은 문자열과 일치하는 문자열을 찾았다는 뜻이다.\r\n\r\n&nbsp;\r\n\r\n## 나이브 문자열 검색 구현\r\n\r\n```jsx\r\nconst naiveSearch = (long, short) => {\r\n    let count = 0;\r\n    for (let i = 0; i < long.length; i++) {\r\n        for (let j = 0; j < short.length; j++) {\r\n            if (short[j] !== long[i + j]) break;\r\n            if (j === short.length - 1) count++;\r\n        }\r\n    }\r\n    return count;\r\n};\r\n\r\nnaiveSearch(\"lorie loled\", \"lol\"); // 1\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"나이브 문자열 검색 (Naive String Search)"},{"data":{"title":"이진 탐색 (Binary Search)","date":"2022-10-06","tags":["TIL","Udemy","Algorithm","이진 탐색","Binary Search"],"draft":false,"summary":"이진 탐색에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 이진 탐색 (Binary Search)\r\n\r\n- 기본적인 개념은 분할 정복 패턴을 사용한다.\r\n  - 배열의 중간점을 찾고, 중간점을 기준으로 찾으려는 값이 속한 집단을 선택, 값을 찾을 때까지 반복\r\n- 한 번 체크할 때 배열의 탐색해야할 요소들을 절반 줄일 수 있다.\r\n- 조건은 배열이 분류되어 있어야 한다는 것이다\r\n    > e.g. 숫자 : 오름차순, 내림차순, 문자열 : abc순, ㄱㄴㄷ순\r\n\r\n\r\n&nbsp;\r\n\r\n# 이진 탐색의 의사코드 (Pseudocode)\r\n\r\n- 정렬된 배열과 `value`를 인자로 받는 함수이다.\r\n- 배열의 시작점을 나타내는 포인터(좌측)와, 배열의 끝을 나타내는 포인터(우측)를 정한다.\r\n- 시작점의 포인터의 값이 끝지점의 포인터보다 크거나 같아질 때까지 연산을 계속한다.\r\n  - 중간점을 찾는다\r\n  - 만약 중간점이 `value`와 같다면 `index`를 리턴한다.\r\n  - `value`보다 중간점이 더 작다면 좌측 포인터의 값을 올린다.\r\n  -` value`보다 중감점이 더 크다면 우측 포인터의 값을 내린다.\r\n  - 원하는 `value`를 찾지 못했다면 `-1`을 리턴한다.\r\n\r\n&nbsp;\r\n\r\n## 이진 탐색 구현\r\n\r\n- 시간 복잡도 : `O(log n)`\r\n- `log 16 = 4`이고 `log 32 = 5`이다.\r\n- `log 16`에서 `16`은 배열의 길이라고 한다면 `4`는 원하는 값을 찾는 작업의 수라고 보면된다.\r\n- 길이가 `16`인 배열에서 중간점을 찾고 원하는 값이 속한 집단을 찾고 이 작업을 `4번`만 반복하면 된다는 뜻이다.\r\n- 배열의 길이가 배로 늘어남에 따라 값을 찾기 위해 찾는 작업을 한 번만 더 하면 되기 때문이다.\r\n\r\n```jsx\r\nconst binarySearch = (arr, value) => {\r\n    let left = 0;\r\n    let right = arr.length - 1;\r\n    let middle = Math.floor((left + right) / 2);\r\n\r\n    while(arr[middle] !== value  && left <= right) {\r\n        if(value > arr[middle]) left = middle + 1;\r\n        else right = middle - 1;\r\n        middle = Math.floor((left + right) / 2);\r\n    }\r\n    return arr[middle] === value ? middle : -1;\r\n}\r\n\r\nbinarySearch([1,2,3,4,5],2) // 1\r\nbinarySearch([1,2,3,4,5],3) // 2\r\nbinarySearch([1,2,3,4,5],5) // 4\r\nbinarySearch([1,2,3,4,5],6) // -1\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"이진 탐색 (Binary Search)"},{"data":{"title":"선형 탐색 (Linear Search)","date":"2022-10-04","tags":["TIL","Udemy","Algorithm","선형 탐색","Linear Search"],"draft":false,"summary":"선형 탐색에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 선형 탐색 (Linear Search)\r\n\r\n- 간단히 설명해서 인수로 배열과 `value`를 넘겨받은 선형 탐색 함수가 있다고 가정할 때\r\n- 배열의 처음부터 끝까지 돌면서 `value`와 일치하는 값을 찾아내는 것이다.\r\n- 자바스크립트에도 선형 탐색을 이용한 메소드들이 있다.\r\n  1. `indexOf`\r\n  2. `includes`\r\n  3. `find`\r\n  4. `findIndex`\r\n\r\n&nbsp;\r\n\r\n## 선형 탐색 구현\r\n\r\n> e.g. 배열과 값을 인수로 받는 함수가 있고, 배열을 돌면서 값과 일차는 배열의 값을 찾으면 해당 index를 리턴하고 찾지 못하면 -1을 리턴해라\r\n\r\n&nbsp;\r\n\r\n## 단순 for문을 이용한 방식\r\n- 시간 복잡도 : `O(n)`\r\n```jsx\r\nconst  linearSearch = (arr, value) => {\r\n\tfor(let i = 0; i < arr.length; i++) {\r\n\t\tif(arr[i] === value) return i;\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nlinearSearch([10, 15, 20, 25, 30], 15) // 1\r\nlinearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 4) // 5\r\nlinearSearch([100], 100) // 0\r\nlinearSearch([1,2,3,4,5], 6) // -1\r\nlinearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 10) // -1\r\nlinearSearch([100], 200) // -1\r\n```\r\n\r\n&nbsp;\r\n\r\n## Helper 메소드를 이용해본 방식\r\n```jsx\r\nconst  linearSearch = (arr, value) => {\r\n    let result = 0;\r\n    const helper = (arr) => {\r\n        if(arr.length === 0) return result = -1;\r\n        if(arr[0] === value) {\r\n            return result;\r\n        } else {\r\n            result ++;\r\n            helper(arr.slice(1));\r\n        }\r\n    }\r\n    helper(arr);\r\n    return result;\r\n}\r\n\r\nlinearSearch([10, 15, 20, 25, 30], 15) // 1\r\nlinearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 4) // 5\r\nlinearSearch([100], 100) // 0\r\nlinearSearch([1,2,3,4,5], 6) // -1\r\nlinearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 10) // -1\r\nlinearSearch([100], 200) // -1\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"선형 탐색 (Linear Search)"},{"data":{"title":"Helper 메소드 재귀 패턴","date":"2022-10-02","tags":["TIL","Udemy","Algorithm","헬퍼 메소드","Helper Method"],"draft":false,"summary":"헬퍼 메소드 재귀 패턴을 이용해서 직관적인 재귀 함수를 구현해보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# Helper 메소드 재귀 패턴\r\n\r\n- 재귀 함수를 실행했을 때 특정 값들을 담은 `배열`을 반환해야하는 경우, 순수 재귀 함수만으로는 까다롭다. 이유는 재귀 함수를 호출 할떄마다\r\n재귀 함수 내의 변수는 초기값으로 리셋되기 마련인데, 이 변수의 값들을 재귀를 돌때마다 이전 값을 유지하면서 반환하는 작업을 따로 구현해주어야 하기 떄문이다.\r\n그렇기 때문에 재귀 함수를 감싸는 함수를 하나 만들어서 그곳에 결과 변수를 하나 두고 재귀 함수를 통해 얻은 특정 값을 담는다.\r\n- Helper 메소드 재귀를 쓰는 것이 더 직관적이다.\r\n\r\n&nbsp;\r\n\r\n## Helper 메소드 재귀 패턴으로 구현했을 때\r\n\r\n- 어떤 결과를 컴파일할 때 흔히 사용되는 패턴이다.\r\n- 재귀 함수를 감싸는 함수를 만들어서 사용하는 패턴이다.\r\n- 이때 감싸는 함수는 재귀로 구현되지 않은 함수이다.\r\n- `collectOddValues()` : 재귀로 구현되지 않은 함수\r\n- `helper()` : 재귀 함수\r\n- `result`를 `helper`함수 안에 정의하게 되면 함수가 호출될 떄마다 빈배열로 리셋되기 때문에 때문에 밖으로 뺸다.\r\n\r\n```jsx\r\nconst collectOddValues = (arr) => {\r\n    let result = [];\r\n    const helper = (helperInput) => {\r\n        if (helperInput.length === 0) {\r\n            return;\r\n        }\r\n        if (helperInput[0] % 2 !== 0) {\r\n            result.push(helperInput[0]);\r\n        }\r\n        helper(helperInput.slice(1));\r\n    };\r\n    helper(arr);\r\n    return result;\r\n};\r\n\r\ncollectOddValues([1, 2, 3, 4]);\r\n```\r\n\r\n&nbsp;\r\n\r\n## 순수 재귀 함수로 구현했을 때\r\n\r\n```jsx\r\nconst collectOddValues = (arr) => {\r\n    let newArr = [];\r\n\r\n    if(arr.length === 0) {\r\n        return newArr;\r\n    }\r\n\r\n    if(arr[0] % 2 !== 0) {\r\n        newArr.push(arr[0]);\r\n    }\r\n\r\n    newArr = newArr.concat(collectionOddvalues(arr.slice(1)));\r\n\r\n    return newArr;\r\n};\r\n\r\n// 순수 재귀 함수의 콜 스택 과정\r\ncollectOddValues([1, 2, 3, 4, 5]); // => [1, 3, 5]\r\n    [1].concat(collectOddValues([2,3,4,5])) // => [3, 5]\r\n                    [ ].concat(collectOddValues([3,4,5])) // => [3, 5]\r\n                                    [3].concat(collectOddValues([4,5])) // => [5]\r\n                                                    [ ].concat(collectOddValues([5])) // => [5]\r\n                                                                    [5].concat(collectOddValues([ ])) // => []\r\n                                                                                    [ ]\r\n```\r\n\r\n&nbsp;\r\n\r\n## Helper 메소드 없이 순수 재귀 함수를 구현했을 때 사용하는 유용한 메소드\r\n\r\n- 배열을 사용하는 경우\r\n    - 배열을 복사하는 `slice, spread 연산자, concat` 같은 메소드를 사용할 수 있다. 그러면 배열을 변경할 필요가 없다.\r\n- 문자열을 사용하는 경우\r\n    - 문자열은 불변하기(변경할 수 없기) 때문에 `slice, substr, substring` 메소드들을 이용해서 문자열의 복사본을 만든다.\r\n- 객체를 사용하는 경우\r\n    - 객체의 경우 `Object.assign, spread 연산자`를 이용해서 복사본을 만들어 구현한다.\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"Helper 메소드 재귀 패턴"}]},"__N_SSG":true}