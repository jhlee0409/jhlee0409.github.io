{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":15},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"버블 정렬 (Bubble Sort)","date":"2022-10-13","tags":["TIL","Udemy","Algorithm","버블 정렬","Bubble Sort Algorithm"],"draft":false,"summary":"버블 정렬에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\n&nbsp;\n\n# 버블 정렬(Bubble Sort)\n\n- `버블 정렬`은 숫자로된 배열을 오름차순으로 정렬을 한다면 더 큰 순자가 한 번에 하나씩 뒤로 이동을 한다는 것이다.\n- `버블 정렬`은 별로 효율적이지도 않고 잘 사용하지 않는다.\n- `싱킹 정렬(Sinking Sort)`라고도 한다.\n- 반복을 한번 돌 때마다 가장 큰 숫자는 우측에 정렬되기 때문에 반복을 거듭할 때마다 정렬해야하는 항목의 수는 감소되게 로직을 짜는 것이 효율적이다.\n- [VisuAlgo - Sorting](https://visualgo.net/en/sorting)는 여러 정렬 알고리즘의 루프 프로세스를 잘 보여준다.\n\n&nbsp;\n\n- 중첩 루프 내의 `swap`을 이용해서 정렬한다.\n\n```javascript\n// ES5\nfunction swap(arr, idx1, idx2) {\n\tvar temp = arr[idx1];\n\tarr[idx1] = arr[idx2];\n\tarr[idx2] = temp;\n}\n\n// ES2015\nconst swap = (arr, idx1, idx2) => {\n\t[arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\n}\n```\n\n# 버블 정렬의 의사코드\n\n- `i` 라는 변수를 갖고 배열의 맨 끝에서 루프를 시작해서 맨 앞에서 끝난다.\n    - why? 배열의 항목 수를 줄이기 위해\n- 외부 반복문 안에는 `j` 라는 변수가 포함된 내부 루프가 있고 내부 루프틑 처음부터 `i - 1` 까지 실행된다,\n- `i` 는 첫 번째 루프를 참조한다. 첫 번째 루프에 의존하는 중첩 루프이다.\n- `arr[j]` 이 `arr[j+1]` 보다 크다면 두 값을 바꾼다.\n- 정렬된 배열을 반환한다.\n\n## 버블 정렬 구현\n\n- 최적화 작업이 안된 버블 정렬은  맨 앞에서 시작해서 맨 끝에서 종료되는 중첩 루프 2개 사용한다.\n```javascript\n// 방안1\nconst bubbleSort = (arr) => {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      console.log(arr, arr[j], arr[j + 1]);\n      if (arr[j] > arr[j + 1]) {\n        // swap\n        let temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n    console.log(\"정렬 한번 끝\");\n  }\n  return arr;\n};\n\n\n// 방안2\nconst bubbleSort = (arr) => {\n  const swap = (arr, idx1, idx2) => {\n    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\n  };\n  for (let i = arr.length; i > 0; i--) {\n    for (let j = 0; j < i - 1; j++) {\n      console.log(arr, arr[j], arr[j + 1]);\n      if (arr[j] > arr[j + 1]) {\n        // swap\n        swap(arr, j, j + 1);\n      }\n    }\n    console.log(\"정렬 한번 끝\");\n  }\n  return arr;\n};\n\nbubbleSort([56,42,12,20]);\n\n// 이미 정렬된 항목은 정렬할 필요가 없음에도 불구하고 루프는 계속 돈다. 그리고 배열의 인덱스를 넘어 비교하는 작업도 한다.\n[56, 42, 12, 20] 56 42\n[42, 56, 12, 20] 56 12\n[42, 12, 56, 20] 56 20\n[42, 12, 20, 56] 56 undefined\n정렬 한번 끝\n[42, 12, 20, 56] 42 12\n[12, 42, 20, 56] 42 20\n[12, 20, 42, 56] 42 56\n[12, 20, 42, 56] 56 undefined\n정렬 한번 끝\n[12, 20, 42, 56] 12 20\n[12, 20, 42, 56] 20 42\n[12, 20, 42, 56] 42 56\n[12, 20, 42, 56] 56 undefined\n정렬 한번 끝\n[12, 20, 42, 56] 12 20\n[12, 20, 42, 56] 20 42\n[12, 20, 42, 56] 42 56\n[12, 20, 42, 56] 56 undefined\n\n// result\n[12, 20, 42, 56]\n```\n\n&nbsp;\n\n- 끝 배열부터 시작하는 이유는 루프를 진행할 수록 비교 횟수를 줄이기 위해서이다.\n\n```javascript\nconst bubbleSort = (arr) => {\n  for (let i = arr.length; i > 0; i--) {\n    for (let j = 0; j < i - 1; j++) {\n      console.log(arr, arr[j], arr[j + 1]);\n      if (arr[j] > arr[j + 1]) {\n        // swap\n        let temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n    console.log(\"정렬 한번 끝\");\n  }\n  return arr;\n};\n\nbubbleSort([56,42,12,20]);\n\n// j < i - 1 로 인해서 루프를 거듭할수록 i이 하나씩 줄어들며 이중 루프가 도는 횟수도 하나씩 줄어든다.\n[56, 42, 12, 20] 56 42\n[42, 56, 12, 20] 56 12\n[42, 12, 56, 20] 56 20\n정렬 한번 끝\n[42, 12, 20, 56] 42 12\n[12, 42, 20, 56] 42 20\n정렬 한번 끝\n[12, 20, 42, 56] 12 20\n정렬 한번 끝\n\n//result\n[12, 20, 42, 56]\n```\n\n&nbsp;\n\n## 최적화\n\n- 거의 정렬된 상태에서는 어떻게 하는게 좋을까\n- 기본적인 버블 정렬은 똑같이 하나하나 비교하며 처리한다.\n- 배열의 루프 횟수를 하나씩 줄여나가기에 정렬이 어느정도 되어있든 없든 루프는 횟수만큼 돈다.\n\n### 해결\n\n- 교환 유무를 판별하는 변수를 하나둔다.\n- 교환이 일어났다면 정렬 중인 것이고 그렇지 않다면 이미 정렬되어 있는 상태이다.\n- 그렇기에 교환이 안되어있다고 판별되면 루프를 빠져나온다.\n\n&nbsp;\n\n#### 최적화 작업 전\n\n```text\n// 28번\n1. [8, 1, 2, 3, 4, 5, 6, 7] 8 1\n2. [1, 8, 2, 3, 4, 5, 6, 7] 8 2\n3. [1, 2, 8, 3, 4, 5, 6, 7] 8 3\n4. [1, 2, 3, 8, 4, 5, 6, 7] 8 4\n5. [1, 2, 3, 4, 8, 5, 6, 7] 8 5\n6. [1, 2, 3, 4, 5, 8, 6, 7] 8 6\n7. [1, 2, 3, 4, 5, 6, 8, 7] 8 7\n 정렬 한번 끝 // ============ 이 시점에서 이미 정렬이 끝났지만 루프는 계속돈다.\n8.[1, 2, 3, 4, 5, 6, 7, 8] 1 2\n...\n26. [1, 2, 3, 4, 5, 6, 7, 8] 1 2\n27. [1, 2, 3, 4, 5, 6, 7, 8] 2 3\n정렬 한번 끝\n28. [1, 2, 3, 4, 5, 6, 7, 8] 1 2\n\n// result\n[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n&nbsp;\n\n#### 최적화 작업 후\n- `noSwaps` 변수를 하나 두고 교환 여부에 따라 값을 바꾼다.\n```javascript\nconst bubbleSort = (arr) => {\n  let noSwaps; // =============== 변수 선언\n  const swap = (arr, idx1, idx2) => {\n    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\n  };\n  for (let i = arr.length; i > 0; i--) {\n    noSwaps = true; // =============== 기본적으로 교환을 안한다고 가정\n    for (let j = 0; j < i - 1; j++) {\n      console.log(arr, arr[j], arr[j + 1]);\n      if (arr[j] > arr[j + 1]) {\n        // swap\n        swap(arr, j, j + 1);\n        noSwaps = false; // =============== 교환을 한다면 false\n      }\n    }\n    console.log(\"정렬 한번 끝\");\n    if (noSwaps) break; // =============== 교환을 하지 않았다면 루프 탈출\n  }\n  return arr;\n};\n\nbubbleSort([8,1,2,3,4,5,6,7]);\n```\n\n\n```text\n// 13번\n1. [8, 1, 2, 3, 4, 5, 6, 7] 8 1\n2. [1, 8, 2, 3, 4, 5, 6, 7] 8 2\n3. [1, 2, 8, 3, 4, 5, 6, 7] 8 3\n4. [1, 2, 3, 8, 4, 5, 6, 7] 8 4\n5. [1, 2, 3, 4, 8, 5, 6, 7] 8 5\n6. [1, 2, 3, 4, 5, 8, 6, 7] 8 6\n7. [1, 2, 3, 4, 5, 6, 8, 7] 8 7\n정렬 한번 끝\n8. [1, 2, 3, 4, 5, 6, 7, 8] 1 2\n9. [1, 2, 3, 4, 5, 6, 7, 8] 2 3\n10. [1, 2, 3, 4, 5, 6, 7, 8] 3 4\n11. [1, 2, 3, 4, 5, 6, 7, 8] 4 5\n12. [1, 2, 3, 4, 5, 6, 7, 8] 5 6\n13. [1, 2, 3, 4, 5, 6, 7, 8] 6 7\n정렬 한번 끝\n\n//result\n[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n\n#### 피드백은 언제나 환영입니다.\n\n\n","path":"버블 정렬 (Bubble Sort)"},{"data":{"title":"정렬 알고리즘 (Sort Algorithm)","date":"2022-10-12","tags":["TIL","Udemy","Algorithm","정렬 알고리즘","Sort Algorithm"],"draft":false,"summary":"정렬 알고리즘과 JS의 배열 내장 메소드인 sort에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\n&nbsp;\n\n# 정렬이란?\n\n- 정렬은 간단히 배열과 같은 컬렉션(collection)의 항목을 재배열하는 과정을 말한다.\n- 배열, 목록, 트리와 같은 다른 데이터 구조도 정렬 가능하다.\n\n    > e.g. 숫자를 오름차순, 내림차순으로 정렬하기\n    >\n\n    > e.g. 문자를 알파벳순, ㄱㄴㄷ순으로 정렬하기\n    >\n\n    > e.g. 개봉 연도 또는 수익 … 을 기준으로 영화 정렬하기\n    >\n\n- [접근 방식에 따른 정렬 알고리즘 YOUTUBE 영상](https://youtu.be/kPRA0W1kECg)\n\n&nbsp;\n\n# 왜 정렬을 배우는 게 필요한가?\n\n- 정렬은 프로그래밍을 함에 있어서 흔히 접하기 때문에 동작 방식을 아는 게 좋다.\n    - 각 언어의 내장된 정렬 메소드를 쓸 때 동작 방식을 알아야 어느 상황 때 어느 메소드를 쓰는 게 좋은지 판단이 가능하다.\n- 다양한 방식의 정렬이 있고 각각 장단점이 있다.\n- 객관적으로 빠른 정렬이 있는 반면, 특정 상황에서 뛰어난 성능을 보여주는 정렬도 있다.\n- [Sorting Algorithms Animations](https://www.toptal.com/developers/sorting-algorithms)에서 어느 상황 때 어느 정렬 알고리즘이 좋은지 시각적 잘 보여준다.\n\n&nbsp;\n\n# Javascript의 배열 내장 메소드인 Array.sort()\n\n- `sort`메소드는 의도한 상황대로 정상적으로 작동하지 않을 때가 있다.\n- 기본적인 `sort`의 동작 방식은 숫자의 순서를 이해하지 못한다.\n- 왜 이해하지 못할까? [MDN Array.prototype.sort()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)를 보면 다음과 같은 이유 때문이다.\n    > 기본 정렬 순서는 문자열의 유니코드 코드 포인트를 따릅니다.\n- 그렇기에 숫자를 의도한 대로 정렬하기 위해서는 추가적인 로직 작성이 필요하다.\n\n```jsx\n// 추가 로직 작성 전\n\n// 오름차순으로 정렬하고자 할 때\n[2, 12, 5, 10].sort(); \n\n// 원하는 결과\n[2, 5, 10, 12]\n\n// 실제 결과\n[10, 12, 2, 5]\n```\n\n&nbsp;\n\n## 추가적인 작업\n\n- `sort()`는 인자로 `선택적 비교 함수(optional comparator function)`를 받을 수 있다.\n- `선택적 비교 함수`를 통해 우리가 원하는 정렬 방식을 전달할 수 있다.\n- `선택적 비교 함수`는 `A와 B`를 비교하고 반환되는 값을 기반으로 정렬한다.\n    - 만약 `음수`를 반환하면 `A는 B보다 앞에 정렬`된다.\n    - 만약 `양수`를 반환하면 `A는 B보다 뒤에 정렬`된다.\n    - 만약 `0`을 반환하면 `A와B는 같은 값이기 때문에 변화는 없다.`\n\n```jsx\n// 오름차순으로 정렬하고자 할 때\n[2, 12, 5, 10].sort((a,b) => {\n\treturn a - b;\n});\n\n// 음수 이기에 2는 12 앞에 정렬\n[2, 12] => 2 - 12 = -10  // [2, 12]\n\n// 양수 이기에 12는 5 뒤에 정렬\n[12, 5] => 12 - 5 = 7  // [2, 5, 12]\n\n// 양수 이기에 12는 10 뒤에 정렬\n[12, 10] => 12 - 10 = 2 // [2, 5, 10, 12]\n\n\n// result\n[2, 5, 10, 12]\n\n```\n\n&nbsp;\n\n- 문자열의 경우에도 어떤 비교함수를 작성하느냐에 따라 정렬 방식을 다양하게 할 수 있다\n\n> e.g. 문자의 길이를 기준으로 정렬하는 경우\n\n```jsx\n[\"Apple\", \"Pear\", \"Strawberry\", \"Cheery\"].sort((a,b)=> {\n\t// 반환되는 값은 0, 음수, 양수\n\treturn a.length - b.length; \n})\n\n// 양수 이기에 Apple은 Pear 뒤에 정렬\n['Apple', 'Pear'] => 5 - 4 = 1 // ['Pear', 'Apple']\n\n// 음수 이기에 Apple은 Strawberry 앞에 정렬\n['Apple', 'Strawberry'] => 5 - 10 = -4  // ['Pear', 'Apple', 'Strawberry']\n\n//양수 이기에 Strawberry는 Cherry 뒤에 정렬\n[\"Strawberry\", \"Cheery\"] => 10 - 6 = 4 // ['Pear', 'Apple', 'Cheery', 'Strawberry']\n\n\n// result\n['Pear', 'Apple', 'Cheery', 'Strawberry']\n```\n\n---\n\n\n#### 피드백은 언제나 환영입니다.","path":"정렬 알고리즘 (Sort Algorithm)"},{"data":{"title":"나이브 문자열 검색 (Naive String Search)","date":"2022-10-09","tags":["TIL","Udemy","Algorithm","나이브 문자열 검색","Naive String Search"],"draft":false,"summary":"나이브 문자열 검색에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n\r\n# 나이브 문자열 검색 (Naive String Search)\r\n\r\n- 긴 문자열에서 부분 문자열을 검색하는 것과 관련이 있다.\r\n- 긴 문자열에서 짧은 문자열이 등장하는 횟수를 세야하는 상황에서 쓰인다.\r\n- 간단한 접근법 중 하나는 문자 하나씩 확인하는 것이다.\r\n\r\n&nbsp;\r\n\r\n# 나이브 문자열 검색의 의사코드 (Pseudocode)\r\n\r\n- 긴 문자열 1개와 짧은 문자열(찾으려는 문자열) 1개를 인자로 받는 함수를 작성한다.\r\n- 긴 문자열의 각 문자를 반복하는 루프를 작성하고 그 안에 짧은 문자열을 반복하는 루프도 하나 작성한다.\r\n- 문자가 일치하지 않으면 내부 루프를 벗어난다. (루프를 멈춘다)\r\n- 문자가 일치하면 계속 진행한다.\r\n- 만약 내부 루프를 완료하고 일치하는 문자열을 찾았으면 `count`를 증가시키고 마지막에 그 `count`를 반환한다.\r\n- 일치하는 문자열이 하나도 없으면 `0` 반환한다.\r\n- 긴 문자열을 반복하는 루프를 만드는 데, 그 루프 안에는 짧은 문자열을 반복하는 중첩(nested loop)가 있다.\r\n- 짧은 문자열의 끝에 도달했는데 아직 루프에서 벗어나지 못했으면 `count`를 `1`을 더한다.\r\n- 루프를 벗어나지 못했다는 뜻은 일치하는 짧은 문자열과 일치하는 문자열을 찾았다는 뜻이다.\r\n\r\n&nbsp;\r\n\r\n## 나이브 문자열 검색 구현\r\n\r\n```jsx\r\nconst naiveSearch = (long, short) => {\r\n    let count = 0;\r\n    for (let i = 0; i < long.length; i++) {\r\n        for (let j = 0; j < short.length; j++) {\r\n            if (short[j] !== long[i + j]) break;\r\n            if (j === short.length - 1) count++;\r\n        }\r\n    }\r\n    return count;\r\n};\r\n\r\nnaiveSearch(\"lorie loled\", \"lol\"); // 1\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"나이브 문자열 검색 (Naive String Search)"},{"data":{"title":"이진 탐색 (Binary Search)","date":"2022-10-06","tags":["TIL","Udemy","Algorithm","이진 탐색","Binary Search"],"draft":false,"summary":"이진 탐색에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 이진 탐색 (Binary Search)\r\n\r\n- 기본적인 개념은 분할 정복 패턴을 사용한다.\r\n  - 배열의 중간점을 찾고, 중간점을 기준으로 찾으려는 값이 속한 집단을 선택, 값을 찾을 때까지 반복\r\n- 한 번 체크할 때 배열의 탐색해야할 요소들을 절반 줄일 수 있다.\r\n- 조건은 배열이 분류되어 있어야 한다는 것이다\r\n    > e.g. 숫자 : 오름차순, 내림차순, 문자열 : abc순, ㄱㄴㄷ순\r\n\r\n\r\n&nbsp;\r\n\r\n# 이진 탐색의 의사코드 (Pseudocode)\r\n\r\n- 정렬된 배열과 `value`를 인자로 받는 함수이다.\r\n- 배열의 시작점을 나타내는 포인터(좌측)와, 배열의 끝을 나타내는 포인터(우측)를 정한다.\r\n- 시작점의 포인터의 값이 끝지점의 포인터보다 크거나 같아질 때까지 연산을 계속한다.\r\n  - 중간점을 찾는다\r\n  - 만약 중간점이 `value`와 같다면 `index`를 리턴한다.\r\n  - `value`보다 중간점이 더 작다면 좌측 포인터의 값을 올린다.\r\n  -` value`보다 중감점이 더 크다면 우측 포인터의 값을 내린다.\r\n  - 원하는 `value`를 찾지 못했다면 `-1`을 리턴한다.\r\n\r\n&nbsp;\r\n\r\n## 이진 탐색 구현\r\n\r\n- 시간 복잡도 : `O(log n)`\r\n- `log 16 = 4`이고 `log 32 = 5`이다.\r\n- `log 16`에서 `16`은 배열의 길이라고 한다면 `4`는 원하는 값을 찾는 작업의 수라고 보면된다.\r\n- 길이가 `16`인 배열에서 중간점을 찾고 원하는 값이 속한 집단을 찾고 이 작업을 `4번`만 반복하면 된다는 뜻이다.\r\n- 배열의 길이가 배로 늘어남에 따라 값을 찾기 위해 찾는 작업을 한 번만 더 하면 되기 때문이다.\r\n\r\n```jsx\r\nconst binarySearch = (arr, value) => {\r\n    let left = 0;\r\n    let right = arr.length - 1;\r\n    let middle = Math.floor((left + right) / 2);\r\n\r\n    while(arr[middle] !== value  && left <= right) {\r\n        if(value > arr[middle]) left = middle + 1;\r\n        else right = middle - 1;\r\n        middle = Math.floor((left + right) / 2);\r\n    }\r\n    return arr[middle] === value ? middle : -1;\r\n}\r\n\r\nbinarySearch([1,2,3,4,5],2) // 1\r\nbinarySearch([1,2,3,4,5],3) // 2\r\nbinarySearch([1,2,3,4,5],5) // 4\r\nbinarySearch([1,2,3,4,5],6) // -1\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"이진 탐색 (Binary Search)"},{"data":{"title":"선형 탐색 (Linear Search)","date":"2022-10-04","tags":["TIL","Udemy","Algorithm","선형 탐색","Linear Search"],"draft":false,"summary":"선형 탐색에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 선형 탐색 (Linear Search)\r\n\r\n- 간단히 설명해서 인수로 배열과 `value`를 넘겨받은 선형 탐색 함수가 있다고 가정할 때\r\n- 배열의 처음부터 끝까지 돌면서 `value`와 일치하는 값을 찾아내는 것이다.\r\n- 자바스크립트에도 선형 탐색을 이용한 메소드들이 있다.\r\n  1. `indexOf`\r\n  2. `includes`\r\n  3. `find`\r\n  4. `findIndex`\r\n\r\n&nbsp;\r\n\r\n## 선형 탐색 구현\r\n\r\n> e.g. 배열과 값을 인수로 받는 함수가 있고, 배열을 돌면서 값과 일차는 배열의 값을 찾으면 해당 index를 리턴하고 찾지 못하면 -1을 리턴해라\r\n\r\n&nbsp;\r\n\r\n## 단순 for문을 이용한 방식\r\n- 시간 복잡도 : `O(n)`\r\n```jsx\r\nconst  linearSearch = (arr, value) => {\r\n\tfor(let i = 0; i < arr.length; i++) {\r\n\t\tif(arr[i] === value) return i;\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nlinearSearch([10, 15, 20, 25, 30], 15) // 1\r\nlinearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 4) // 5\r\nlinearSearch([100], 100) // 0\r\nlinearSearch([1,2,3,4,5], 6) // -1\r\nlinearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 10) // -1\r\nlinearSearch([100], 200) // -1\r\n```\r\n\r\n&nbsp;\r\n\r\n## Helper 메소드를 이용해본 방식\r\n```jsx\r\nconst  linearSearch = (arr, value) => {\r\n    let result = 0;\r\n    const helper = (arr) => {\r\n        if(arr.length === 0) return result = -1;\r\n        if(arr[0] === value) {\r\n            return result;\r\n        } else {\r\n            result ++;\r\n            helper(arr.slice(1));\r\n        }\r\n    }\r\n    helper(arr);\r\n    return result;\r\n}\r\n\r\nlinearSearch([10, 15, 20, 25, 30], 15) // 1\r\nlinearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 4) // 5\r\nlinearSearch([100], 100) // 0\r\nlinearSearch([1,2,3,4,5], 6) // -1\r\nlinearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 10) // -1\r\nlinearSearch([100], 200) // -1\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"선형 탐색 (Linear Search)"}]},"__N_SSG":true}