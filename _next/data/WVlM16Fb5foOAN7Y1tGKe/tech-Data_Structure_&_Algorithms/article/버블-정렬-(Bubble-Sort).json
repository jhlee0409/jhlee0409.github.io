{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":15},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":{"title":"버블 정렬 (Bubble Sort)","date":"2022-10-13","tags":["TIL","Udemy","Algorithm","버블 정렬","Bubble Sort Algorithm"],"draft":false,"summary":"버블 정렬에 대해 알아보자"},"content":"\n&nbsp;\n\n# 버블 정렬(Bubble Sort)\n\n- `버블 정렬`은 숫자로된 배열을 오름차순으로 정렬을 한다면 더 큰 순자가 한 번에 하나씩 뒤로 이동을 한다는 것이다.\n- `버블 정렬`은 별로 효율적이지도 않고 잘 사용하지 않는다.\n- `싱킹 정렬(Sinking Sort)`라고도 한다.\n- 반복을 한번 돌 때마다 가장 큰 숫자는 우측에 정렬되기 때문에 반복을 거듭할 때마다 정렬해야하는 항목의 수는 감소되게 로직을 짜는 것이 효율적이다.\n- [VisuAlgo - Sorting](https://visualgo.net/en/sorting)는 여러 정렬 알고리즘의 루프 프로세스를 잘 보여준다.\n\n&nbsp;\n\n- 중첩 루프 내의 `swap`을 이용해서 정렬한다.\n\n```javascript\n// ES5\nfunction swap(arr, idx1, idx2) {\n\tvar temp = arr[idx1];\n\tarr[idx1] = arr[idx2];\n\tarr[idx2] = temp;\n}\n\n// ES2015\nconst swap = (arr, idx1, idx2) => {\n\t[arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\n}\n```\n\n# 버블 정렬의 의사코드\n\n- `i` 라는 변수를 갖고 배열의 맨 끝에서 루프를 시작해서 맨 앞에서 끝난다.\n    - why? 배열의 항목 수를 줄이기 위해\n- 외부 반복문 안에는 `j` 라는 변수가 포함된 내부 루프가 있고 내부 루프틑 처음부터 `i - 1` 까지 실행된다,\n- `i` 는 첫 번째 루프를 참조한다. 첫 번째 루프에 의존하는 중첩 루프이다.\n- `arr[j]` 이 `arr[j+1]` 보다 크다면 두 값을 바꾼다.\n- 정렬된 배열을 반환한다.\n\n## 버블 정렬 구현\n\n- 최적화 작업이 안된 버블 정렬은  맨 앞에서 시작해서 맨 끝에서 종료되는 중첩 루프 2개 사용한다.\n```javascript\n// 방안1\nconst bubbleSort = (arr) => {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      console.log(arr, arr[j], arr[j + 1]);\n      if (arr[j] > arr[j + 1]) {\n        // swap\n        let temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n    console.log(\"정렬 한번 끝\");\n  }\n  return arr;\n};\n\n\n// 방안2\nconst bubbleSort = (arr) => {\n  const swap = (arr, idx1, idx2) => {\n    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\n  };\n  for (let i = arr.length; i > 0; i--) {\n    for (let j = 0; j < i - 1; j++) {\n      console.log(arr, arr[j], arr[j + 1]);\n      if (arr[j] > arr[j + 1]) {\n        // swap\n        swap(arr, j, j + 1);\n      }\n    }\n    console.log(\"정렬 한번 끝\");\n  }\n  return arr;\n};\n\nbubbleSort([56,42,12,20]);\n\n// 이미 정렬된 항목은 정렬할 필요가 없음에도 불구하고 루프는 계속 돈다. 그리고 배열의 인덱스를 넘어 비교하는 작업도 한다.\n[56, 42, 12, 20] 56 42\n[42, 56, 12, 20] 56 12\n[42, 12, 56, 20] 56 20\n[42, 12, 20, 56] 56 undefined\n정렬 한번 끝\n[42, 12, 20, 56] 42 12\n[12, 42, 20, 56] 42 20\n[12, 20, 42, 56] 42 56\n[12, 20, 42, 56] 56 undefined\n정렬 한번 끝\n[12, 20, 42, 56] 12 20\n[12, 20, 42, 56] 20 42\n[12, 20, 42, 56] 42 56\n[12, 20, 42, 56] 56 undefined\n정렬 한번 끝\n[12, 20, 42, 56] 12 20\n[12, 20, 42, 56] 20 42\n[12, 20, 42, 56] 42 56\n[12, 20, 42, 56] 56 undefined\n\n// result\n[12, 20, 42, 56]\n```\n\n&nbsp;\n\n- 끝 배열부터 시작하는 이유는 루프를 진행할 수록 비교 횟수를 줄이기 위해서이다.\n\n```javascript\nconst bubbleSort = (arr) => {\n  for (let i = arr.length; i > 0; i--) {\n    for (let j = 0; j < i - 1; j++) {\n      console.log(arr, arr[j], arr[j + 1]);\n      if (arr[j] > arr[j + 1]) {\n        // swap\n        let temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n    console.log(\"정렬 한번 끝\");\n  }\n  return arr;\n};\n\nbubbleSort([56,42,12,20]);\n\n// j < i - 1 로 인해서 루프를 거듭할수록 i이 하나씩 줄어들며 이중 루프가 도는 횟수도 하나씩 줄어든다.\n[56, 42, 12, 20] 56 42\n[42, 56, 12, 20] 56 12\n[42, 12, 56, 20] 56 20\n정렬 한번 끝\n[42, 12, 20, 56] 42 12\n[12, 42, 20, 56] 42 20\n정렬 한번 끝\n[12, 20, 42, 56] 12 20\n정렬 한번 끝\n\n//result\n[12, 20, 42, 56]\n```\n\n&nbsp;\n\n## 최적화\n\n- 거의 정렬된 상태에서는 어떻게 하는게 좋을까\n- 기본적인 버블 정렬은 똑같이 하나하나 비교하며 처리한다.\n- 배열의 루프 횟수를 하나씩 줄여나가기에 정렬이 어느정도 되어있든 없든 루프는 횟수만큼 돈다.\n\n### 해결\n\n- 교환 유무를 판별하는 변수를 하나둔다.\n- 교환이 일어났다면 정렬 중인 것이고 그렇지 않다면 이미 정렬되어 있는 상태이다.\n- 그렇기에 교환이 안되어있다고 판별되면 루프를 빠져나온다.\n\n&nbsp;\n\n#### 최적화 작업 전\n\n```text\n// 28번\n1. [8, 1, 2, 3, 4, 5, 6, 7] 8 1\n2. [1, 8, 2, 3, 4, 5, 6, 7] 8 2\n3. [1, 2, 8, 3, 4, 5, 6, 7] 8 3\n4. [1, 2, 3, 8, 4, 5, 6, 7] 8 4\n5. [1, 2, 3, 4, 8, 5, 6, 7] 8 5\n6. [1, 2, 3, 4, 5, 8, 6, 7] 8 6\n7. [1, 2, 3, 4, 5, 6, 8, 7] 8 7\n 정렬 한번 끝 // ============ 이 시점에서 이미 정렬이 끝났지만 루프는 계속돈다.\n8.[1, 2, 3, 4, 5, 6, 7, 8] 1 2\n...\n26. [1, 2, 3, 4, 5, 6, 7, 8] 1 2\n27. [1, 2, 3, 4, 5, 6, 7, 8] 2 3\n정렬 한번 끝\n28. [1, 2, 3, 4, 5, 6, 7, 8] 1 2\n\n// result\n[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n&nbsp;\n\n#### 최적화 작업 후\n- `noSwaps` 변수를 하나 두고 교환 여부에 따라 값을 바꾼다.\n```javascript\nconst bubbleSort = (arr) => {\n  let noSwaps; // =============== 변수 선언\n  const swap = (arr, idx1, idx2) => {\n    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\n  };\n  for (let i = arr.length; i > 0; i--) {\n    noSwaps = true; // =============== 기본적으로 교환을 안한다고 가정\n    for (let j = 0; j < i - 1; j++) {\n      console.log(arr, arr[j], arr[j + 1]);\n      if (arr[j] > arr[j + 1]) {\n        // swap\n        swap(arr, j, j + 1);\n        noSwaps = false; // =============== 교환을 한다면 false\n      }\n    }\n    console.log(\"정렬 한번 끝\");\n    if (noSwaps) break; // =============== 교환을 하지 않았다면 루프 탈출\n  }\n  return arr;\n};\n\nbubbleSort([8,1,2,3,4,5,6,7]);\n```\n\n\n```text\n// 13번\n1. [8, 1, 2, 3, 4, 5, 6, 7] 8 1\n2. [1, 8, 2, 3, 4, 5, 6, 7] 8 2\n3. [1, 2, 8, 3, 4, 5, 6, 7] 8 3\n4. [1, 2, 3, 8, 4, 5, 6, 7] 8 4\n5. [1, 2, 3, 4, 8, 5, 6, 7] 8 5\n6. [1, 2, 3, 4, 5, 8, 6, 7] 8 6\n7. [1, 2, 3, 4, 5, 6, 8, 7] 8 7\n정렬 한번 끝\n8. [1, 2, 3, 4, 5, 6, 7, 8] 1 2\n9. [1, 2, 3, 4, 5, 6, 7, 8] 2 3\n10. [1, 2, 3, 4, 5, 6, 7, 8] 3 4\n11. [1, 2, 3, 4, 5, 6, 7, 8] 4 5\n12. [1, 2, 3, 4, 5, 6, 7, 8] 5 6\n13. [1, 2, 3, 4, 5, 6, 7, 8] 6 7\n정렬 한번 끝\n\n//result\n[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n\n#### 피드백은 언제나 환영입니다.\n\n\n"},"__N_SSG":true}