{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":5},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"슬라이딩 윈도우 패턴 (Sliding Window Pattern)","date":"2022-09-26","tags":["TIL","Udemy","Algorithm","슬라이딩 윈도우 패턴","Sliding Window Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 슬라이딩 윈도우 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 슬라이딩 윈도우 패턴 (Sliding Window Pattern)\r\n\r\n- 위치를 조정할 수 있는 특정 길이의 가상의 `window`을 하나 설정한 후, ` window`의 위치를 좌에서 우 또는 우에서 좌로 이동시키면서 특정 조건을 만족하는 값을 찾아내는 것이다.\r\n- `window`는 단일 변수, 하위 배열, 또는 필요한 경우 다른 문자열도 될 수 있다.\r\n- 배열/문자열 등의 데이터를 입력하거나 특정 방식으로 연속적인 해당 데이터의 하위 집합을 찾는 경우에 유용하다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 배열과 숫자 하나를 전달 → 연속되는 n개의 숫자의 합계가 가장 큰 값을 구해라\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n^2)`\r\n- `for`문 을 이용한 이중 반복문\r\n\r\n```js\r\nconst max = (arr, n) => {\r\n    if (n > arr.length) return null;\r\n\r\n    // 배열이 만약 모두 음수로 구성되어 있다면 가장 큰합은 여전히 음수일 것이기 떄문이다.\r\n    // 전부 양수이지 않는한 0으로 설정하지 않는다.\r\n    let result = -Infinity;\r\n    for (let i = 0; i < arr.length - n + 1; i++){\r\n        temp = 0;\r\n        for (let j = 0; j < n; j++) {\r\n            temp += arr[i + j];\r\n        }\r\n        if(temp > result) {\r\n            result = temp;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//            v  v\r\nmax([1, 2, 5, 2, 8, 1, 5], 2) // 10\r\n```\r\n\r\n## 빈도  카운터 패턴\r\n\r\n- 시간 복잡도 : `O(n)`\r\n\r\n```js\r\nconst max = (arr, n) => {\r\n    let max = 0;\r\n    let temp = 0;\r\n    if(arr.length < n) return null;\r\n\r\n    // 맨 처음 0번에서 시작하는 n개의 합을 구해서 max로 설정\r\n    // e.g. 1, 2 의 합인 3을 초기 값으로 세팅\r\n    // [v  v]\r\n    // [1, 2, 5, 2, 8, 1, 5]\r\n    for(let i = 0; i < n; i++) {\r\n        max += arr[i]\r\n    }\r\n    temp = max;\r\n        // 그 다음부터는 맨 처음 설정한 max값을 for문들 돌면서 n개의 값을 더하는 게 아닌 위치를 window의 첫 위치의 값을 빼고 window의 다음 위치에 있는 값을 더한다.\r\n        //  - [v  +]             ->    [v  v]\r\n        // [1, 2, 5, 2, 8, 1, 5] -> [1, 2, 5, 2, 8, 1, 5]\r\n        // 그래서 그 값을 임시로 저장하고 기존 amx값과 비교해서 최대값을 갱신해 나간다.\r\n        // for문의 n값부터 시작한다.\r\n    for(let i = n; i < arr.length; i++) {\r\n        // 2 - 2 = 0번쨰 인덱스의 값을 뺴고 / 2번째 인덱스의 값을 더한다.\r\n        //  0 [1  2]\r\n        // [1, 2, 5, 2, 8, 1, 5]\r\n        temp = temp - arr[i - n] + arr[i];\r\n        max = Math.max(max, temp)\r\n    }\r\n    return max\r\n}\r\n\r\n//           [v  v]\r\nmax([1, 2, 5, 2, 8, 1, 5], 2) // 10\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"슬라이딩 윈도우 패턴 (Sliding Window Pattern)"},{"data":{"title":"다중 포인터 패턴 (Multiple Pointers Pattern)","date":"2022-09-24","tags":["TIL","Udemy","Algorithm","다중 포인터 패턴","Multiple Pointers Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 다중 포인터 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 다중 포인터 패턴 (Multiple Pointers Pattern)\r\n\r\n- 인덱스나 위치에 해당하는 `포인터나 값`을 만든 다음 특정 조건에 따라 중간 지점에서부터 `시작 지점`이나 `끝 지점`이나 `양쪽 지점`을 향해 이동시킨다.\r\n- 두 개의 포인터를 지정하고 포인터의 위치를 변경하면서 `특정 조건에 맞는 쌍 or 값`을 찾는 것\r\n\r\n&nbsp;\r\n\r\n> e.g. 정렬된 배열을 취하는 `sumZero` 라는 함수 작성.\r\n오름차순으로 정렬되어 있어야 한다.\r\n처음으로 합해서 0이 되는 쌍을  찾으면 된다.\r\n\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n^2)`\r\n- 공간 복잡도 : `O(1)`\r\n- `for문`이중 반복문을 사용한다.\r\n\r\n```js\r\nconst sumZero = (arr) => {\r\n    for(const i in arr) {\r\n        for (const j in arr) {\r\n        // 합이 0이면 해당 값들 리턴\r\n        // 나올 때까지 돈다... 돌다가 나오면 리턴 아니면 끝까지 쭉 하고 undefined\r\n         if(arr[i] + arr[j] === 0) {\r\n             return [arr[i], arr[j]]\r\n         }\r\n        }\r\n    }\r\n};\r\nsumZero([-4, -3, -2, -1, 0 , 1, 2, 5]) // [-2, 2]\r\n```\r\n\r\n## 빈도  카운터 패턴\r\n\r\n- 시간 복잡도 : `O(n)`\r\n- 공간 복잡도 : `O(1)`\r\n- 양 끝에 인덱스를 포인터로 지정하고 합이 0에 맞는 값을 찾아나가는 과정이다.\r\n- 합이 0이 안된다면 좌, 우의 포인터를 한 칸씩 번갈아서 가운데 방향을 이동시키면서 합이 0이되는 인덱스의 값을 찾아낸다.\r\n\r\n```js\r\nconst sumZero = (arr) => {\r\n    let left = 0; // 배열의 첫번째 인덱스 지정\r\n    let right = arr.length - 1; // 배열의 끝 지점에 인덱스 지정\r\n\r\n    while(left < right) {\r\n      const sumNumber = arr[left] + arr[right];\r\n        // 합이 0이면 해당 값들 리턴\r\n        if(sumNumber === 0) {\r\n            return [arr[left], arr[right]]\r\n        // 합이 0보다 크면 우측 포지션 -1\r\n        } else if (arr[left] + arr[right] > 0) {\r\n            right--;\r\n        //합이 0보다 작거나 같으면 좌측 포지션 + 1\r\n        } else {\r\n            left++;\r\n        }\r\n    }\r\n};\r\n\r\nsumZero([-4, -3, -2, -1, 0 , 1, 2, 5])\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"다중 포인터 패턴 (Multiple Pointers Pattern)"},{"data":{"title":"빈도수 카운터 패턴 (Frequency Counters Pattern)","date":"2022-09-24","tags":["TIL","Udemy","Algorithm","빈도수 카운터 패턴","Frequency Counters Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 빈도수 카운터 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n# 1. 빈도수 카운터 패턴 (Frequency Counters Pattern)\r\n\r\n- 자바스크립트의 객체를 이용해서 값과 빈도수를 체크한다.\r\n- 두 개의 배열을 객체로 세분화하고 각 배열의 요소들을 분류하고 비교한다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 2개의 배열을 이용하는 same 함수가 있다. 두번째 배열의 값들은 첫번쨰 배열의 값들의 제곱이다. 각 값들의 빈도 수가 같아야한다.\r\n\r\n\r\n## 일반적인 패턴 `O(n^2)`\r\n\r\n- `for문`과 `indexOf`메소드를 이용한 이중 반복문\r\n\r\n```js\r\nconst same = (first, second) => {\r\n    // 두 배열의 길이가 다르면 false\r\n    if (first.length !== second.length) return false;\r\n    for (const i in first) {\r\n        // 두번째 배열에 매칭되는 인덱스 찾기\r\n        const correct = second.indexOf(first[i] ** 2);\r\n        // 없으면 false\r\n        if (correct === -1) return false;\r\n        // 있으면 체크 후 제거\r\n        second.splice(correct, 1);\r\n    }\r\n    return true;\r\n  };\r\n\r\nsame([1, 2, 3, 2], [4, 1, 9, 4])\r\n```\r\n\r\n## 빈도  카운터 패턴 `O(n)`\r\n\r\n- 이중 반복문을 돌리는 대신 각 배열을 한번씩만 반복문 적용\r\n- 이중 반복문보다 빠르다.\r\n- 두 객체를 사용해서 각 배열 `value`의 빈도수를 체크 (`value`가 각 배열에서 몇 번 나왔는지 알 수 있다.)\r\n- 만둘어진 객체의 `key`를 체크하는 반복문을 작성해서 하나의 객체에만 적용시켜주면 된다. (여기서는 `frequencyCounter1`)\r\n```js\r\nconst same = (first, second) => {\r\n    if (first.length !== second.length) return false;\r\n    let frequencyCounter1 = {}; // {1: 1, 2: 2, 3: 1}\r\n    let frequencyCounter2 = {}; // {1: 1, 4: 2, 9: 1}\r\n    for (const val of first) {\r\n        // 없으면 1로, 있으면 1씩 더함\r\n        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;\r\n    }\r\n    for (const val of second) {\r\n        // 없으면 1로, 있으면 1씩 더함\r\n        frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;\r\n    }\r\n    for (const key in frequencyCounter1) {\r\n        // 매칭되는 key가 있는지 체크\r\n        if (!(key ** 2 in frequencyCounter2)) {\r\n            return false;\r\n        }\r\n        // 해당 key를 이용해서 매칭되는 value의 빈도수가 같은지 체크\r\n        if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    // 모든 조건 통과시 true\r\n    return true;\r\n  };\r\n\r\nsame([1, 2, 3, 2], [4, 1, 9, 4])\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"빈도수 카운터 패턴 (Frequency Counters Pattern)"},{"data":{"title":"빅오로 보는 배열과 객체의 성능 평가","date":"2022-09-22","tags":["TIL","Udemy","Data Structure","빅오","Big O","Object","Array"],"draft":false,"summary":"배열과 객체 그리고 내장된 메소드들의 성능은?","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n# 1. 객체(Object)의 빅오(Big O)\r\n\r\n- 객체는 정렬되어 있지 않다.\r\n- 저장, 접근, 제거, 수정의 경우 `O(1)`이 걸린다.\r\n- 탐색은 단순하게 `key`에 접근하는 것이 아닌 `value`를 가져와야하기에 `O(n)`이 걸린다.\r\n\r\n    ```js\r\n     const obj = { name: \"jack\", age: 0 };\r\n    // 'jack' 이라는 값이 어디에 저장되어 있는가를 알기위해서는 모든 `key`값을 돌며 `value`를 체크해야한다.\r\n    ```\r\n\r\n- `Object.keys, Object.values, Object.entries` 메소드들의 경우 `O(n)`이 걸린다.\r\n    - 객체를 돌며 다 배열에 담아 반환해야하기 떄문이다.\r\n- `hasOwnProperty`의 경우 `O(1)`이 걸린다.\r\n    - `key`가 있는지 없는지 바로 접근이 가능하기 때문이다.\r\n\r\n&nbsp;\r\n\r\n# 2. 배열(Array)의 빅오(Big O)\r\n\r\n- 배열은 정렬된 데이터이다. 그렇기에 각 값에 인덱스가 붙어있다.\r\n\r\n- 접근의 경우 `O(1)`이 걸린다.\r\n    - `index`로 바로 접근하면 되기 때문이다.\r\n\r\n- 탐색은 객체와 동일하게 `O(n)`이 걸린다.\r\n\r\n- 저장의 경우 어디에 저장하느냐에 따라 빅오가 달라진다.\r\n    - `push`메소드는 배열의 끝에 저장하기 때문에 `O(1)`이 걸린다.\r\n    - `unshift`메소드는 배열의 처음에 저장하기 때문에 `O(n)`이 걸린다.\r\n\r\n- 제거의 경우도 어디를 제거하느냐에 따라 빅오가 달라진다.\r\n  - `pop` 메소드는 배열의 끝값을 제거하기 때문에 `O(1)`이 걸린다.\r\n  - `shift`메소드는 배열의 처음값을 제거하기 때문에 `O(n)`이 걸린다.\r\n\r\n&nbsp;\r\n\r\n## 왜? 같은 저장, 제거인데 다르죠?\r\n\r\n- 인덱스 번호의 재배치 때문이다.\r\n- 배열의 끝에 `저장/제거`하는 경우는 끝에 값이 있기 때문에 다른 값들의 인덱스는 변화가 없다.\r\n- 하지만 배열의 처음에 `저장/제거`하는 경우는 그 작업을 수행한 후 나머지 값들의 인덱스를 재배치 해주어야하기 때문이다.\r\n\r\n    ```js\r\n    // 기존의 0번 인덱스에 위치한 값은 \"A\"이지만 shift 호출이후 \"B\"로 바뀌게 된다.\r\n    // 즉, 0번 인덱스의 값이 제거가 되면 나머지 값들의 인덱스 번호가 하나씩 떙겨져 재배치 된다.\r\n    const arr = [\"A\", \"B\", \"C\", \"D\"];\r\n    arr[0] // \"A\"\r\n    arr.shift()\r\n    arr[0] // \"B\"\r\n    ```\r\n\r\n- 비어있는 배열의 경우를 제외하고 `push, pop`메소드는 `shift, unshift`보다 빠르다.\r\n- `push, pop`메소드의 경우`O(1)`이 걸린다.\r\n- `shift, unshift, concat, slice, splice`메소드의 경우 `O(n)`이 걸린다.\r\n- `sort`메소드의 경우 `O(n* log n)`이 걸린다. (추후 포스팅)\r\n- `forEach, map, filter, reduce`메소드의 경우 `O(n)`이 걸린다.\r\n\r\n\r\n---\r\n\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"빅오로 보는 배열과 객체의 성능 평가"},{"data":{"title":"[Programming] 프레임워크와 라이브러리의 차이","date":"2022-09-20","tags":["TIL","Programming","Framework","Library"],"draft":false,"summary":"프레임워크와 라이브러리의 차이에 대해 알아보자","mainCategory":"tech","subCategory":"programming"},"content":"\r\n# 서론\r\n\r\n- 흔히 프로그래밍을 하는 사람이라면 한번 쯤 들어보고 생각해봤을 주제이다.\r\n- 이 부분에 대해 깊게 관심을 가지는 사람들도 있는 반면 자연스럽게 스쳐지나갔을 수도 있다.\r\n- 본인들이 사용하는 기술들의 사이트를 방문해보면 이게 라이브러리인지 프레임워크인지 명시가 되어있다.\r\n- 그렇다면 왜 각 기술들은 라이브러리? 프레임워크? 비슷해보이지만 다른 둘, 어떤 기준으로 정하는 것일까?\r\n- 바로 그러면 프레임워크와 라이브러리가 어떤 것인지 그리고 차이점은 뭔지 알아보자.\r\n\r\n&nbsp;\r\n\r\n> e.g. Frontend\r\n\r\n![좌측 상단부터 React, Vue,js, Next.js, Recoil](/assets/posts/til/Programming/framework&library/05.png)\r\n\r\n\r\n\r\n# 프레임워크(Framework)란?\r\n\r\n> 한줄 설명: 일정한 틀 안에서 틀이 정한 일정한 규칙에 따라 작성해야한다.\r\n\r\n- 프레임워크는 그들이 제공하는 규칙과 가이드라인이 있으며 사용자는 이에 맞게 코드를 작성해 나가야한다.\r\n- 규칙과 가이드라인을 벗어나서 코드를 작성하면 정상적으로 동작하지 않을 수 있다.\r\n\r\n&nbsp;\r\n\r\n# 라이브러리(Library)란?\r\n\r\n> 한줄 설명: 여러 기능들을 담은 말그대로 도서관! 내가 원하는 것만 골라 꺼내 쓸 수 있다.\r\n\r\n- 라이브러리의 제작자가 코드를 작성해 기능을 만들고 그것들을 모듈화 해놓은 것이다.\r\n- 해당 라이브러리에서 만들어놓은 컴포넌트나 메소드, 등을 내가 원하는 곳에서 내가 원할 때 그리고 내가 필요한 것들을 호출해 가져다 쓰기만 하면된다.\r\n- 본인이 따로 커스텀할 수 있는 옵션이 있다면 그것 또한 라이브러리에서 제공하는 기능이므로 내가 필요할 때 옵션을 넣기만하면 된다.\r\n- 기본적으로 호출해서 바로 쓸 수 있다.\r\n\r\n&nbsp;\r\n\r\n# 공통점\r\n\r\n- 재사용 가능하다.\r\n\r\n    - 라이브러리의 경우 어디서나 내가 원할 떄 호출이 가능하니 호출이 즉 재사용을 의미한다.\r\n    - 프레임워크의 경우 흐름에 맞춰 본인이 작성해놓은 코드를 원하는 곳에서 호출이 가능하다.\r\n\r\n&nbsp;\r\n\r\n# 차이점\r\n\r\n1. 사용의 주도권을 누가 쥐고 있느냐\r\n\r\n    - 프레임워크 : 프레임워크 자체가 쥐고 있으며 사용자는 프레임워크가 제시한 규칙에 따라 코드를 작성해야한다.\r\n    - 라이브러리 : 사용자가 쥐고 있으며, 사용자는 자신이 원하는 기능만 호출해 사용하면 된다.\r\n\r\n&nbsp;\r\n\r\n2. 프레임워크는 라이브러리를 포함한다.\r\n\r\n    - 프레임워크는 코드를 작성함에 있어서 필요한 라이브러리(기능)들을 제공해 줄 수 있다.\r\n\r\n![출처는 참고링크](/assets/posts/til/Programming/framework&library/06.png)\r\n\r\n&nbsp;\r\n\r\n3. 라이브러리도 정해진 규칙에 따라 호출해야하는 게 아닌가요?\r\n\r\n    - 필자가 생각하는 가장 큰 차이점은 호출 즉시 바로 사용할 수 있느냐 이다.\r\n\r\n    > e.g. 내가 A라는 기능을 원하는 경우\r\n\r\n    - 라이브러리의 경우 찾아서 A 기능을 쓰면 된다.\r\n    - 프레임워크의 경우 A 기능을 프레임워크에서 제공한 방식에 따라 직접 구현한다. A 기능을 제공한다면 그건 프레임워크의 라이브러리이다.\r\n    - 프레임워크에서 제공하는 기능들 때문에 이게 프레임워크인지 라이브러리인지 헷갈릴 수도 있다.\r\n\r\n\r\n&nbsp;\r\n\r\n4. 내가 지금 작성하고 있는 코드가 근간이 되는 언어에서 기반이 된건지 아니면 프레임워크나 라이브러리가 기반이 되는지 잘 보아야한다.\r\n\r\n    > e.g. React와 Vue.js에서 반복문을 쓰는 경우\r\n\r\n    - React\r\n\r\n    ```jsx\r\n    // React의 경우 반복문의 구현자체는 자바스크립트의 반복문을 사용하는 것이다.\r\n    // map이 아니더라도 for-in, for-of, for 다양하게 사용해서 구현 가능하다.\r\n    // map 사용\r\n    <div id=\"list-rendering\">\r\n      <ol>\r\n         {todos.map((todo)=> {\r\n             return (\r\n                 <li key={todo.id} >{todo.text}</li>\r\n             )\r\n         })}\r\n      </ol>\r\n    </div>\r\n    ```\r\n   &nbsp;\r\n\r\n    - Vue.js\r\n\r\n    ```vue\r\n    // 반드시 vue 에서 정한 규칙에 따라 반복문을 구현해야한다.\r\n    <div id=\"list-rendering\">\r\n      <ol>\r\n        <li v-for=\"todo in todos\">\r\n          {{ todo.text }}\r\n        </li>\r\n      </ol>\r\n    </div>\r\n    ```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n### 참고\r\n- [What is the difference between a framework and a library?](https://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library)\r\n\r\n\r\n---\r\n\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"[Programming] 프레임워크와 라이브러리의 차이"}]},"__N_SSG":true}