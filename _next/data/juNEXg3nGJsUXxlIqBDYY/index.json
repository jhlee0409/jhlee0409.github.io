{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":8},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"재귀 함수 예제","date":"2022-09-29","tags":["TIL","Udemy","Algorithm","재귀 함수 예제","Recursive Function","Recursion"],"draft":false,"summary":"재귀 함수 예제 2가지를 살펴보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 재귀 함수\r\n\r\n- 기본적인 개념은 동일한 함수를 계속 호출하면서, 하나의 함수가 자기 자신을 재귀적으로 호출하게 하는 것이다\r\n- 어떤 재귀 함수든 반드시 갖춰야 하는 두 가지 요소가 있다.\r\n  1. `종료 조건`(재귀가 멈추는 시점)이 있어야 한다.\r\n  2. `다른 입력값`을 받아야한다. (재귀 함수를 호출할 때 매번 다른 데이터가 들어와야한다.)\r\n\r\n# 첫번째 재귀 함수\r\n\r\n- `countDown(0)` => 종료 조건 `if문`에서 걸려 종료된다\r\n- 종료 조건에서 `return` 하지않으면 콘솔만 찍히고 계속 진행된다.\r\n    - `return`을 꼭하거나 `else문`을 써서 종료시켜야한다.\r\n```jsx\r\n  const countDown = (num) => {\r\n    if (num <= 0) { // 종료 조건\r\n      console.log(\"All done!\");\r\n      // return 하지않으면 콘솔만 찍히고 재귀 함수는 계속 진행된다.\r\n      return;\r\n      // 아니면 else 문을 써야한다.\r\n    }\r\n    console.log(num);\r\n    num--;\r\n    countDown(num);\r\n  };\r\n\r\ncountDown(10)  // 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 3 -> 1 -> All done!\r\n```\r\n\r\n# 두번째 재귀 함수\r\n\r\n- 첫번째 재귀 함수와 다른 점은 재귀 함수가 계속해서 `return` 한다는 것이다\r\n- 여기서 이전 포스팅 내용인 `콜 스택`의 개념을 알면 이해하기 쉽다\r\n    1. `sumRange(3)`함수를 가정 먼저 호출하게 되면 1층에 쌓인다.\r\n    2. `sumRange(3)`함수 내의 `sumRange(2)`함수를 호출하게 되고 `sumRange(3)`은 `return`한게 없기 때문에 1층에 그대로 있고 위에 얹혀서 2층에 쌓인다.\r\n    3. `sumRange(2)`함수 내의 `sumRange(1)`함수를 호출하게 되고 `sumRange(2)`은 `return`한게 없기 때문에 2층에 그대로 있고 위에 얹혀서 3층에 쌓인다.\r\n    4. `sumRange(1)`함수 호출 시 `if문(종료 조건)`에 걸려 `1`을 반환하고 콜 스택에서 제거된다.\r\n    5. `sumRange(2)`함수는 `sumRange(1)`에서 반환된 값 `1`과 `num`값인 `2`를 더한 값인 `3 (= 2 + sumRange(1))`을 반환하고 콜 스택에서 제거된다.\r\n    6. `sumRange(3)`함수는 `sumRange(2)`에서 반환된 값 `3`과 `num`값인 `3`를 더한 값인 `6 (= 3 + sumRange(2))`을 반환하고 콜 스택에서 제거된다.\r\n    7. 결과적으로 `6`을 반환한다.\r\n\r\n```jsx\r\n  const sumRange = (num) => {\r\n    if (num === 1) return 1; // 종료 조건\r\n    return num + sumRange(num - 1);\r\n  };\r\n\r\n// 콜 스택 과정\r\nsumRange(3) // 6\r\n    return 3 + sumRange(2) // 3 + 3\r\n                    return 2 + sumRange(1) // 2 + 1\r\n                                    return 1\r\n```\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"재귀 함수 예제"},{"data":{"title":"콜 스택 (Call Stack)","date":"2022-09-29","tags":["TIL","Udemy","콜 스택","호출 스택","Call Stack"],"draft":false,"summary":"콜 스택에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 콜 스택 (Call Stack)\r\n\r\n- 대부분의 프로그래밍 언어에서는 함수 호출을 관리하는 데이터 구조가 있다.\r\n- 자바스크립트에서 함수 호출을 관리하는 것이 `콜 스택`이다.\r\n- `콜 스택`은 자바스크립트의 보이지 않는 곳에서 작동하는 정적 데이터 구조이다.\r\n- 함수를 호출하게 되면 `콜 스택`에 스택이 쌓이게 되고 가장 위에 쌓인 함수부터 처리후 `콜 스택`에서 제거된다.\r\n- `콜 스택`에서 제거되는 조건은 함수가 종료되거나 `return`을 하게 되었을 떄이다.\r\n\r\n&nbsp;\r\n\r\n# 콜 스택이 동작하는 과정\r\n\r\n- 콜 스택의 과정을 보여주기 위해 작성한 코드 이다.\r\n- `trigger` 함수에 `breakpoint`를 걸고 우측의 `콜 스택` 블럭을 통해 진행 과정을 알아보자\r\n\r\n![trigger 함수 호출](/assets/posts/til/DS&Al/콜스택/01.png)\r\n\r\n&nbsp;\r\n\r\n## 1. trigger 함수 호출\r\n\r\n- 먼저 `trigger` 함수가 호출되면 콜 스택에 쌓인다.\r\n\r\n![trigger 함수를 콜 스택에 추가](/assets/posts/til/DS&Al/콜스택/02.png)\r\n\r\n&nbsp;\r\n\r\n## 2. firstFn 함수 호출\r\n\r\n- 이전에 호출된 `trigger` 함수에서 `firstFn` 함수를 호출\r\n- 콜 스택에 `firstFn` 함수가 쌓이게 된다.\r\n- 아직 `trigger` 함수는 끝나지 않은 상태임과 동시에 가장 먼저 호출된 함수이기 때문에 가장 아래에 위치해 있다.\r\n\r\n![firstFn 함수를 콜 스택에 추가](/assets/posts/til/DS&Al/콜스택/03.png)\r\n\r\n- 이후 `firstFn` 함수는 `return` 을 한다.\r\n\r\n![firstFn 함수에서 값을 return](/assets/posts/til/DS&Al/콜스택/04.png)\r\n\r\n- `return`을 했으니 콜 스택에서 `firstFn` 함수는 제거 된다.\r\n\r\n![firstFn 함수를 콜 스택에서 제거](/assets/posts/til/DS&Al/콜스택/05.png)\r\n\r\n&nbsp;\r\n\r\n## 3. secondFn 함수 호출\r\n\r\n- `trigger` 함수에서 `firstFn` 함수가 호출/제거 된 후, `secondFn` 함수를 호출하게되면 콜 스택에 쌓인다.\r\n- 이 때도 아직 `trigger` 함수는 끝나지 않았기 때문에 아직 콜 스택에 남아있다.\r\n\r\n![secondFn 함수를 콜 스택에 추가](/assets/posts/til/DS&Al/콜스택/06.png)\r\n\r\n\r\n- 이 후 `secondFn` 함수에서 `generateNumber` 함수를 호출하면 콜스택에 쌓인다.\r\n- 이 때 아직 `secondFn` 함수는 끝나지 않았기 때문에 콜스택에 남아있다.\r\n> 사진에서 generateNumnber -> generateNumber 로 오타 정정\r\n\r\n![secondFn 함수에서 값을 return](/assets/posts/til/DS&Al/콜스택/07.png)\r\n\r\n\r\n- `generateNumber` 함수가 `1`이란 값을 `return` 했기 때문에 종료 후 콜 스택에서 제거된다.\r\n\r\n![secondFn 함수를 콜 스택에서 제거](/assets/posts/til/DS&Al/콜스택/08.png)\r\n\r\n\r\n- 이후 secondFn 함수는 `generateNumber` 함수에서 `return`된 값 `1`을 가지고 `return`을 하게 된다.\r\n- 이렇게 `secondFn` 함수도 `return`한 후 콜 스택에서 제거된다.\r\n\r\n&nbsp;\r\n\r\n## 4. trigger 함수 종료\r\n\r\n- `secondFn` 함수도 종료/제거가 되면서 `trigger`함수는 마지막 남은 `console.log`를 띄운다.\r\n\r\n![trigger 함수에서 condole.log를 띄움](/assets/posts/til/DS&Al/콜스택/09.png)\r\n\r\n\r\n- `console.log`를 띄운 후 `trigger` 함수도 종료가 된다.\r\n\r\n![trigger 함수에서 띄운 log](/assets/posts/til/DS&Al/콜스택/10.png)\r\n\r\n![trigger 함수를 콜 스택에서 제거](/assets/posts/til/DS&Al/콜스택/11.png)\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"콜 스택 (Call Stack)"},{"data":{"title":"분할과 정복 패턴 (Divide and Conquer Pattern)","date":"2022-09-27","tags":["TIL","Udemy","Algorithm","분할과 정복 패턴","Divide and Conquer Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 분할과 정복 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 분할과 정복 패턴 (Divide and Conquer Pattern)\r\n\r\n- 주로 배열이나 문자열 같은 큰 규모의 데이터셋을 처리한다.\r\n- 이진 탐색이나 병합 정렬, 퀵 정렬 등에 사용되는 패턴이다.\r\n- 값을 찾기 위해 배열의 왼쪽에서 시작하여 오른쪽 끝까지 이동하는 것이 아닌 배열을 작은 조각으로 `세분`하여 각 조각들을 `어디로 이동`시킬지 결정하는 작업부터 시작한다.\r\n- 즉, 큰 데이터 덩어리를 작은 조각으로 나누는 거다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 정수로 이루어진 정렬된 배열과 찾으려는 값이 주어지면 배열에서 해당 값이 있는 인덱스(위치)를 반환하는 search라는 함수를 작성해라. 값을 찾을 수 없으면 -1을 반환한다.\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n)`\r\n- 선형 탐색\r\n- `arr`가 주어진다면 최대 `arr`의 길이만큼 반복해야 한다.\r\n\r\n```js\r\nconst search = (arr, val) => {\r\n\tfor(let i = 0; i < arr.length; i++) {\r\n\t\tif(arr[i] === val) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nsearch([1,2,3,4,5,6], 4) // 3\r\n```\r\n\r\n## 분할과 정복 패턴\r\n\r\n- 시간 복잡도 : `Log(n)`\r\n- 이진 탐색\r\n- 배열의 중간 값을 찾고나면 넘겨진 `val`이 속하는 배열을 골라 다시 중간 값을 찾고 `val`이 속한 배열을 골라서 `val`의 위치를 찾아낼 때까지 반복하는 작업\r\n\r\n```js\r\nconst search = (arr, val) => {\r\n  let min = 0;\r\n  let max = arr.length - 1;\r\n\r\n  while (min <= max) {\r\n\t\t// 배열의 중간 인덱스 (소수점 버림)\r\n    let middle = Math.floor((min + max) / 2);\r\n\r\n\t\t// 중간 인덱스의 값이 찾으려는 값보다 작으면\r\n\t\t// 찾으려는 값은 중간 인덱스의 값보다 큰 쪽에 속해 있다.\r\n\t\t// 증간 인덱스 보다 낮은 인덱스의 값들은 필요가 없으므로 min 값 갱신\r\n\t\t// e.g. 중간 인덱스의 값 = 3 / val = 4\r\n\t\t// 3이 4보다 작으니 3보다 작은 값들은 필요가 없다.\r\n    if (arr[middle] < val) {\r\n      min = middle + 1;\r\n    } else if (arr[middle] > val) {\r\n\t\t// 중간 인덱스의 값이 찾으려는 값보다 크면\r\n\t\t// 찾으려는 값은 중간 인덱스의 값보다 작은 쪽에 속해 있다.\r\n\t\t// 증간 인덱스 보다 큰 인덱스의 값들은 필요가 없으므로 max 값 갱신\r\n\t\t// e.g. 중간 인덱스의 값 = 7 / val = 4\r\n\t\t// 7이 4보다 크니 7보다 큰 값들은 필요가 없다.\r\n      max = middle - 1;\r\n    } else {\r\n        // 중간 인덱스의 값이 찾으려는 값과 같으면 바로 return\r\n        // e.g. 중간 인덱스의 값 = 4 / val = 4\r\n        // 중간 인덱스의 값이 찾으려는 값과 같으므로 위치 바로 return\r\n      return middle;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nsearch([1,2,3,4,5,6], 4) // 3\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"분할과 정복 패턴 (Divide and Conquer Pattern)"},{"data":{"title":"슬라이딩 윈도우 패턴 (Sliding Window Pattern)","date":"2022-09-26","tags":["TIL","Udemy","Algorithm","슬라이딩 윈도우 패턴","Sliding Window Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 슬라이딩 윈도우 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 슬라이딩 윈도우 패턴 (Sliding Window Pattern)\r\n\r\n- 위치를 조정할 수 있는 특정 길이의 가상의 `window`을 하나 설정한 후, ` window`의 위치를 좌에서 우 또는 우에서 좌로 이동시키면서 특정 조건을 만족하는 값을 찾아내는 것이다.\r\n- `window`는 단일 변수, 하위 배열, 또는 필요한 경우 다른 문자열도 될 수 있다.\r\n- 배열/문자열 등의 데이터를 입력하거나 특정 방식으로 연속적인 해당 데이터의 하위 집합을 찾는 경우에 유용하다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 배열과 숫자 하나를 전달 → 연속되는 n개의 숫자의 합계가 가장 큰 값을 구해라\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n^2)`\r\n- `for`문 을 이용한 이중 반복문\r\n\r\n```js\r\nconst max = (arr, n) => {\r\n    if (n > arr.length) return null;\r\n\r\n    // 배열이 만약 모두 음수로 구성되어 있다면 가장 큰합은 여전히 음수일 것이기 떄문이다.\r\n    // 전부 양수이지 않는한 0으로 설정하지 않는다.\r\n    let result = -Infinity;\r\n    for (let i = 0; i < arr.length - n + 1; i++){\r\n        temp = 0;\r\n        for (let j = 0; j < n; j++) {\r\n            temp += arr[i + j];\r\n        }\r\n        if(temp > result) {\r\n            result = temp;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//            v  v\r\nmax([1, 2, 5, 2, 8, 1, 5], 2) // 10\r\n```\r\n\r\n## 빈도  카운터 패턴\r\n\r\n- 시간 복잡도 : `O(n)`\r\n\r\n```js\r\nconst max = (arr, n) => {\r\n    let max = 0;\r\n    let temp = 0;\r\n    if(arr.length < n) return null;\r\n\r\n    // 맨 처음 0번에서 시작하는 n개의 합을 구해서 max로 설정\r\n    // e.g. 1, 2 의 합인 3을 초기 값으로 세팅\r\n    // [v  v]\r\n    // [1, 2, 5, 2, 8, 1, 5]\r\n    for(let i = 0; i < n; i++) {\r\n        max += arr[i]\r\n    }\r\n    temp = max;\r\n        // 그 다음부터는 맨 처음 설정한 max값을 for문들 돌면서 n개의 값을 더하는 게 아닌 위치를 window의 첫 위치의 값을 빼고 window의 다음 위치에 있는 값을 더한다.\r\n        //  - [v  +]             ->    [v  v]\r\n        // [1, 2, 5, 2, 8, 1, 5] -> [1, 2, 5, 2, 8, 1, 5]\r\n        // 그래서 그 값을 임시로 저장하고 기존 amx값과 비교해서 최대값을 갱신해 나간다.\r\n        // for문의 n값부터 시작한다.\r\n    for(let i = n; i < arr.length; i++) {\r\n        // 2 - 2 = 0번쨰 인덱스의 값을 뺴고 / 2번째 인덱스의 값을 더한다.\r\n        //  0 [1  2]\r\n        // [1, 2, 5, 2, 8, 1, 5]\r\n        temp = temp - arr[i - n] + arr[i];\r\n        max = Math.max(max, temp)\r\n    }\r\n    return max\r\n}\r\n\r\n//           [v  v]\r\nmax([1, 2, 5, 2, 8, 1, 5], 2) // 10\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"슬라이딩 윈도우 패턴 (Sliding Window Pattern)"},{"data":{"title":"다중 포인터 패턴 (Multiple Pointers Pattern)","date":"2022-09-24","tags":["TIL","Udemy","Algorithm","다중 포인터 패턴","Multiple Pointers Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 다중 포인터 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 다중 포인터 패턴 (Multiple Pointers Pattern)\r\n\r\n- 인덱스나 위치에 해당하는 `포인터나 값`을 만든 다음 특정 조건에 따라 중간 지점에서부터 `시작 지점`이나 `끝 지점`이나 `양쪽 지점`을 향해 이동시킨다.\r\n- 두 개의 포인터를 지정하고 포인터의 위치를 변경하면서 `특정 조건에 맞는 쌍 or 값`을 찾는 것\r\n\r\n&nbsp;\r\n\r\n> e.g. 정렬된 배열을 취하는 `sumZero` 라는 함수 작성.\r\n오름차순으로 정렬되어 있어야 한다.\r\n처음으로 합해서 0이 되는 쌍을  찾으면 된다.\r\n\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n^2)`\r\n- 공간 복잡도 : `O(1)`\r\n- `for문`이중 반복문을 사용한다.\r\n\r\n```js\r\nconst sumZero = (arr) => {\r\n    for(const i in arr) {\r\n        for (const j in arr) {\r\n        // 합이 0이면 해당 값들 리턴\r\n        // 나올 때까지 돈다... 돌다가 나오면 리턴 아니면 끝까지 쭉 하고 undefined\r\n         if(arr[i] + arr[j] === 0) {\r\n             return [arr[i], arr[j]]\r\n         }\r\n        }\r\n    }\r\n};\r\nsumZero([-4, -3, -2, -1, 0 , 1, 2, 5]) // [-2, 2]\r\n```\r\n\r\n## 빈도  카운터 패턴\r\n\r\n- 시간 복잡도 : `O(n)`\r\n- 공간 복잡도 : `O(1)`\r\n- 양 끝에 인덱스를 포인터로 지정하고 합이 0에 맞는 값을 찾아나가는 과정이다.\r\n- 합이 0이 안된다면 좌, 우의 포인터를 한 칸씩 번갈아서 가운데 방향을 이동시키면서 합이 0이되는 인덱스의 값을 찾아낸다.\r\n\r\n```js\r\nconst sumZero = (arr) => {\r\n    let left = 0; // 배열의 첫번째 인덱스 지정\r\n    let right = arr.length - 1; // 배열의 끝 지점에 인덱스 지정\r\n\r\n    while(left < right) {\r\n      const sumNumber = arr[left] + arr[right];\r\n        // 합이 0이면 해당 값들 리턴\r\n        if(sumNumber === 0) {\r\n            return [arr[left], arr[right]]\r\n        // 합이 0보다 크면 우측 포지션 -1\r\n        } else if (arr[left] + arr[right] > 0) {\r\n            right--;\r\n        //합이 0보다 작거나 같으면 좌측 포지션 + 1\r\n        } else {\r\n            left++;\r\n        }\r\n    }\r\n};\r\n\r\nsumZero([-4, -3, -2, -1, 0 , 1, 2, 5])\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"다중 포인터 패턴 (Multiple Pointers Pattern)"}]},"__N_SSG":true}