{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":13},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"나이브 문자열 검색 (Naive String Search)","date":"2022-10-09","tags":["TIL","Udemy","Algorithm","나이브 문자열 검색","Naive String Search"],"draft":false,"summary":"나이브 문자열 검색에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n\r\n# 나이브 문자열 검색 (Naive String Search)\r\n\r\n- 긴 문자열에서 부분 문자열을 검색하는 것과 관련이 있다.\r\n- 긴 문자열에서 짧은 문자열이 등장하는 횟수를 세야하는 상황에서 쓰인다.\r\n- 간단한 접근법 중 하나는 문자 하나씩 확인하는 것이다.\r\n\r\n&nbsp;\r\n\r\n# 나이브 문자열 검색의 의사코드 (Pseudocode)\r\n\r\n- 긴 문자열 1개와 짧은 문자열(찾으려는 문자열) 1개를 인자로 받는 함수를 작성한다.\r\n- 긴 문자열의 각 문자를 반복하는 루프를 작성하고 그 안에 짧은 문자열을 반복하는 루프도 하나 작성한다.\r\n- 문자가 일치하지 않으면 내부 루프를 벗어난다. (루프를 멈춘다)\r\n- 문자가 일치하면 계속 진행한다.\r\n- 만약 내부 루프를 완료하고 일치하는 문자열을 찾았으면 `count`를 증가시키고 마지막에 그 `count`를 반환한다.\r\n- 일치하는 문자열이 하나도 없으면 `0` 반환한다.\r\n- 긴 문자열을 반복하는 루프를 만드는 데, 그 루프 안에는 짧은 문자열을 반복하는 중첩(nested loop)가 있다.\r\n- 짧은 문자열의 끝에 도달했는데 아직 루프에서 벗어나지 못했으면 `count`를 `1`을 더한다.\r\n- 루프를 벗어나지 못했다는 뜻은 일치하는 짧은 문자열과 일치하는 문자열을 찾았다는 뜻이다.\r\n\r\n&nbsp;\r\n\r\n## 나이브 문자열 검색 구현\r\n\r\n```jsx\r\nconst naiveSearch = (long, short) => {\r\n    let count = 0;\r\n    for (let i = 0; i < long.length; i++) {\r\n        for (let j = 0; j < short.length; j++) {\r\n            if (short[j] !== long[i + j]) break;\r\n            if (j === short.length - 1) count++;\r\n        }\r\n    }\r\n    return count;\r\n};\r\n\r\nnaiveSearch(\"lorie loled\", \"lol\"); // 1\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"나이브 문자열 검색 (Naive String Search)"},{"data":{"title":"이진 탐색 (Binary Search)","date":"2022-10-06","tags":["TIL","Udemy","Algorithm","이진 탐색","Binary Search"],"draft":false,"summary":"이진 탐색에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 이진 탐색 (Binary Search)\r\n\r\n- 기본적인 개념은 분할 정복 패턴을 사용한다.\r\n  - 배열의 중간점을 찾고, 중간점을 기준으로 찾으려는 값이 속한 집단을 선택, 값을 찾을 때까지 반복\r\n- 한 번 체크할 때 배열의 탐색해야할 요소들을 절반 줄일 수 있다.\r\n- 조건은 배열이 분류되어 있어야 한다는 것이다\r\n    > e.g. 숫자 : 오름차순, 내림차순, 문자열 : abc순, ㄱㄴㄷ순\r\n\r\n\r\n&nbsp;\r\n\r\n# 이진 탐색의 의사코드 (Pseudocode)\r\n\r\n- 정렬된 배열과 `value`를 인자로 받는 함수이다.\r\n- 배열의 시작점을 나타내는 포인터(좌측)와, 배열의 끝을 나타내는 포인터(우측)를 정한다.\r\n- 시작점의 포인터의 값이 끝지점의 포인터보다 크거나 같아질 때까지 연산을 계속한다.\r\n  - 중간점을 찾는다\r\n  - 만약 중간점이 `value`와 같다면 `index`를 리턴한다.\r\n  - `value`보다 중간점이 더 작다면 좌측 포인터의 값을 올린다.\r\n  -` value`보다 중감점이 더 크다면 우측 포인터의 값을 내린다.\r\n  - 원하는 `value`를 찾지 못했다면 `-1`을 리턴한다.\r\n\r\n&nbsp;\r\n\r\n## 이진 탐색 구현\r\n\r\n- 시간 복잡도 : `O(log n)`\r\n- `log 16 = 4`이고 `log 32 = 5`이다.\r\n- `log 16`에서 `16`은 배열의 길이라고 한다면 `4`는 원하는 값을 찾는 작업의 수라고 보면된다.\r\n- 길이가 `16`인 배열에서 중간점을 찾고 원하는 값이 속한 집단을 찾고 이 작업을 `4번`만 반복하면 된다는 뜻이다.\r\n- 배열의 길이가 배로 늘어남에 따라 값을 찾기 위해 찾는 작업을 한 번만 더 하면 되기 때문이다.\r\n\r\n```jsx\r\nconst binarySearch = (arr, value) => {\r\n    let left = 0;\r\n    let right = arr.length - 1;\r\n    let middle = Math.floor((left + right) / 2);\r\n\r\n    while(arr[middle] !== value  && left <= right) {\r\n        if(value > arr[middle]) left = middle + 1;\r\n        else right = middle - 1;\r\n        middle = Math.floor((left + right) / 2);\r\n    }\r\n    return arr[middle] === value ? middle : -1;\r\n}\r\n\r\nbinarySearch([1,2,3,4,5],2) // 1\r\nbinarySearch([1,2,3,4,5],3) // 2\r\nbinarySearch([1,2,3,4,5],5) // 4\r\nbinarySearch([1,2,3,4,5],6) // -1\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"이진 탐색 (Binary Search)"},{"data":{"title":"Helper 메소드 재귀 패턴","date":"2022-10-02","tags":["TIL","Udemy","Algorithm","헬퍼 메소드","Helper Method"],"draft":false,"summary":"헬퍼 메소드 재귀 패턴을 이용해서 직관적인 재귀 함수를 구현해보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\n&nbsp;\n\n# Helper 메소드 재귀 패턴\n\n- 재귀 함수를 실행했을 때 특정 값들을 담은 `배열`을 반환해야하는 경우, 순수 재귀 함수만으로는 까다롭다. 이유는 재귀 함수를 호출 할떄마다\n재귀 함수 내의 변수는 초기값으로 리셋되기 마련인데, 이 변수의 값들을 재귀를 돌때마다 이전 값을 유지하면서 반환하는 작업을 따로 구현해주어야 하기 떄문이다.\n그렇기 때문에 재귀 함수를 감싸는 함수를 하나 만들어서 그곳에 결과 변수를 하나 두고 재귀 함수를 통해 얻은 특정 값을 담는다.\n- Helper 메소드 재귀를 쓰는 것이 더 직관적이다.\n\n&nbsp;\n\n## Helper 메소드 재귀 패턴으로 구현했을 때\n\n- 어떤 결과를 컴파일할 때 흔히 사용되는 패턴이다.\n- 재귀 함수를 감싸는 함수를 만들어서 사용하는 패턴이다.\n- 이때 감싸는 함수는 재귀로 구현되지 않은 함수이다.\n- `collectOddValues()` : 재귀로 구현되지 않은 함수\n- `helper()` : 재귀 함수\n- `result`를 `helper`함수 안에 정의하게 되면 함수가 호출될 떄마다 빈배열로 리셋되기 때문에 때문에 밖으로 뺸다.\n\n```jsx\nconst collectOddValues = (arr) => {\n    let result = [];\n    const helper = (helperInput) => {\n        if (helperInput.length === 0) {\n            return;\n        }\n        if (helperInput[0] % 2 !== 0) {\n            result.push(helperInput[0]);\n        }\n        helper(helperInput.slice(1));\n    };\n    helper(arr);\n    return result;\n};\n\ncollectOddValues([1, 2, 3, 4]);\n```\n\n&nbsp;\n\n## 순수 재귀 함수로 구현했을 때\n\n```jsx\nconst collectOddValues = (arr) => {\n    let newArr = [];\n\n    if(arr.length === 0) {\n        return newArr;\n    }\n\n    if(arr[0] % 2 !== 0) {\n        newArr.push(arr[0]);\n    }\n\n    newArr = newArr.concat(collectionOddvalues(arr.slice(1)));\n\n    return newArr;\n};\n\n// 순수 재귀 함수의 콜 스택 과정\ncollectOddValues([1, 2, 3, 4, 5]); // => [1, 3, 5]\n    [1].concat(collectOddValues([2,3,4,5])) // => [3, 5]\n                    [ ].concat(collectOddValues([3,4,5])) // => [3, 5]\n                                    [3].concat(collectOddValues([4,5])) // => [5]\n                                                    [ ].concat(collectOddValues([5])) // => [5]\n                                                                    [5].concat(collectOddValues([ ])) // => []\n                                                                                    [ ]\n```\n\n&nbsp;\n\n## Helper 메소드 없이 순수 재귀 함수를 구현했을 때 사용하는 유용한 메소드\n\n- 배열을 사용하는 경우\n    - 배열을 복사하는 `slice, spread 연산자, concat` 같은 메소드를 사용할 수 있다. 그러면 배열을 변경할 필요가 없다.\n- 문자열을 사용하는 경우\n    - 문자열은 불변하기(변경할 수 없기) 때문에 `slice, substr, substring` 메소드들을 이용해서 문자열의 복사본을 만든다.\n- 객체를 사용하는 경우\n    - 객체의 경우 `Object.assign, spread 연산자`를 이용해서 복사본을 만들어 구현한다.\n---\n\n#### 피드백은 언제나 환영입니다.","path":"Helper 메소드 재귀 패턴"},{"data":{"title":"Helper 메소드 재귀 패턴","date":"2022-10-02","tags":["TIL","Udemy","Algorithm","헬퍼 메소드","Helper Method"],"draft":false,"summary":"헬퍼 메소드 재귀 패턴을 이용해서 직관적인 재귀 함수를 구현해보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# Helper 메소드 재귀 패턴\r\n\r\n- 재귀 함수를 실행했을 때 특정 값들을 담은 `배열`을 반환해야하는 경우, 순수 재귀 함수만으로는 까다롭다. 이유는 재귀 함수를 호출 할떄마다\r\n재귀 함수 내의 변수는 초기값으로 리셋되기 마련인데, 이 변수의 값들을 재귀를 돌때마다 이전 값을 유지하면서 반환하는 작업을 따로 구현해주어야 하기 떄문이다.\r\n그렇기 때문에 재귀 함수를 감싸는 함수를 하나 만들어서 그곳에 결과 변수를 하나 두고 재귀 함수를 통해 얻은 특정 값을 담는다.\r\n- Helper 메소드 재귀를 쓰는 것이 더 직관적이다.\r\n\r\n&nbsp;\r\n\r\n## Helper 메소드 재귀 패턴으로 구현했을 때\r\n\r\n- 어떤 결과를 컴파일할 때 흔히 사용되는 패턴이다.\r\n- 재귀 함수를 감싸는 함수를 만들어서 사용하는 패턴이다.\r\n- 이때 감싸는 함수는 재귀로 구현되지 않은 함수이다.\r\n- `collectOddValues()` : 재귀로 구현되지 않은 함수\r\n- `helper()` : 재귀 함수\r\n- `result`를 `helper`함수 안에 정의하게 되면 함수가 호출될 떄마다 빈배열로 리셋되기 때문에 때문에 밖으로 뺸다.\r\n\r\n```jsx\r\nconst collectOddValues = (arr) => {\r\n    let result = [];\r\n    const helper = (helperInput) => {\r\n        if (helperInput.length === 0) {\r\n            return;\r\n        }\r\n        if (helperInput[0] % 2 !== 0) {\r\n            result.push(helperInput[0]);\r\n        }\r\n        helper(helperInput.slice(1));\r\n    };\r\n    helper(arr);\r\n    return result;\r\n};\r\n\r\ncollectOddValues([1, 2, 3, 4]);\r\n```\r\n\r\n&nbsp;\r\n\r\n## 순수 재귀 함수로 구현했을 때\r\n\r\n```jsx\r\nconst collectOddValues = (arr) => {\r\n    let newArr = [];\r\n\r\n    if(arr.length === 0) {\r\n        return newArr;\r\n    }\r\n\r\n    if(arr[0] % 2 !== 0) {\r\n        newArr.push(arr[0]);\r\n    }\r\n\r\n    newArr = newArr.concat(collectionOddvalues(arr.slice(1)));\r\n\r\n    return newArr;\r\n};\r\n\r\n// 순수 재귀 함수의 콜 스택 과정\r\ncollectOddValues([1, 2, 3, 4, 5]); // => [1, 3, 5]\r\n    [1].concat(collectOddValues([2,3,4,5])) // => [3, 5]\r\n                    [ ].concat(collectOddValues([3,4,5])) // => [3, 5]\r\n                                    [3].concat(collectOddValues([4,5])) // => [5]\r\n                                                    [ ].concat(collectOddValues([5])) // => [5]\r\n                                                                    [5].concat(collectOddValues([ ])) // => []\r\n                                                                                    [ ]\r\n```\r\n\r\n&nbsp;\r\n\r\n## Helper 메소드 없이 순수 재귀 함수를 구현했을 때 사용하는 유용한 메소드\r\n\r\n- 배열을 사용하는 경우\r\n    - 배열을 복사하는 `slice, spread 연산자, concat` 같은 메소드를 사용할 수 있다. 그러면 배열을 변경할 필요가 없다.\r\n- 문자열을 사용하는 경우\r\n    - 문자열은 불변하기(변경할 수 없기) 때문에 `slice, substr, substring` 메소드들을 이용해서 문자열의 복사본을 만든다.\r\n- 객체를 사용하는 경우\r\n    - 객체의 경우 `Object.assign, spread 연산자`를 이용해서 복사본을 만들어 구현한다.\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"Helper 메소드 재귀 패턴"},{"data":{"title":"팩토리얼(Factorial) 구현하기","date":"2022-09-30","tags":["TIL","Udemy","Algorithm","팩토리얼","Factorial"],"draft":false,"summary":"반복문과 재귀 함수로 팩토리얼을 구현해보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\n&nbsp;\n\n# 팩토리얼(Factorial)\n\n- 재귀 함수를 이용한 가장 흔한 패턴은 팩토리얼을 구현하는 것이다.\n- 팩토리얼은 `n!`이며 n이 양의 정수일 때 1부터 n까지 그 수들을 모두 곱하는 것이다.  `0!의 경우 1이다.`\n- 단순 반복문과 재귀 함수로 팩토리얼을 구현해보자.\n\n\n# 1. 반복문으로  팩토리얼 구현하기\n\n```jsx\nconst factorial = (num) => {\n    let result = 1;\n    for(let i = 1; i <= num; i++) {\n        result *= i;\n    }\n    return result\n}\n\nfactorial(5) // 120\n```\n\n# 재귀 함수로 팩토리얼 구현하기\n\n- 해당 로직의 이해가 필요하다면 [이전 포스팅](https://jhlee0409.github.io/tech-Data_Structure_&_Algorithms/article/%EC%9E%AC%EA%B7%80-%ED%95%A8%EC%88%98-%EC%98%88%EC%A0%9C)에서 두 번째 재귀 함수 구현 부분을 보면 참고하면 된다.\n\n```jsx\nconst factorial = (num) => {\n    // 0!과 1!은 1이기 때문에 종료조건을 아래와 같이 세팅\n    // 안걸면 음수까지 가면서 영원히 계산된다.\n    if (num <= 1) return 1;\n    return num * factorial(num-1);\n  }\n\nfactorial(5) // 120\n```\n\n---\n\n#### 피드백은 언제나 환영입니다.","path":"팩토리얼(Factorial) 구현하기"},{"data":{"title":"재귀 함수 예제","date":"2022-09-29","tags":["TIL","Udemy","Algorithm","재귀 함수 예제","Recursive Function","Recursion"],"draft":false,"summary":"재귀 함수 예제 2가지를 살펴보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 재귀 함수\r\n\r\n- 기본적인 개념은 동일한 함수를 계속 호출하면서, 하나의 함수가 자기 자신을 재귀적으로 호출하게 하는 것이다\r\n- 어떤 재귀 함수든 반드시 갖춰야 하는 두 가지 요소가 있다.\r\n  1. `종료 조건`(재귀가 멈추는 시점)이 있어야 한다.\r\n  2. `다른 입력값`을 받아야한다. (재귀 함수를 호출할 때 매번 다른 데이터가 들어와야한다.)\r\n\r\n# 첫번째 재귀 함수\r\n\r\n- `countDown(0)` => 종료 조건 `if문`에서 걸려 종료된다\r\n- 종료 조건에서 `return` 하지않으면 콘솔만 찍히고 계속 진행된다.\r\n    - `return`을 꼭하거나 `else문`을 써서 종료시켜야한다.\r\n```jsx\r\n  const countDown = (num) => {\r\n    if (num <= 0) { // 종료 조건\r\n      console.log(\"All done!\");\r\n      // return 하지않으면 콘솔만 찍히고 재귀 함수는 계속 진행된다.\r\n      return;\r\n      // 아니면 else 문을 써야한다.\r\n    }\r\n    console.log(num);\r\n    num--;\r\n    countDown(num);\r\n  };\r\n\r\ncountDown(10)  // 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 3 -> 1 -> All done!\r\n```\r\n\r\n# 두번째 재귀 함수\r\n\r\n- 첫번째 재귀 함수와 다른 점은 재귀 함수가 계속해서 `return` 한다는 것이다\r\n- 여기서 이전 포스팅 내용인 `콜 스택`의 개념을 알면 이해하기 쉽다\r\n    1. `sumRange(3)`함수를 가정 먼저 호출하게 되면 1층에 쌓인다.\r\n    2. `sumRange(3)`함수 내의 `sumRange(2)`함수를 호출하게 되고 `sumRange(3)`은 `return`한게 없기 때문에 1층에 그대로 있고 위에 얹혀서 2층에 쌓인다.\r\n    3. `sumRange(2)`함수 내의 `sumRange(1)`함수를 호출하게 되고 `sumRange(2)`은 `return`한게 없기 때문에 2층에 그대로 있고 위에 얹혀서 3층에 쌓인다.\r\n    4. `sumRange(1)`함수 호출 시 `if문(종료 조건)`에 걸려 `1`을 반환하고 콜 스택에서 제거된다.\r\n    5. `sumRange(2)`함수는 `sumRange(1)`에서 반환된 값 `1`과 `num`값인 `2`를 더한 값인 `3 (= 2 + sumRange(1))`을 반환하고 콜 스택에서 제거된다.\r\n    6. `sumRange(3)`함수는 `sumRange(2)`에서 반환된 값 `3`과 `num`값인 `3`를 더한 값인 `6 (= 3 + sumRange(2))`을 반환하고 콜 스택에서 제거된다.\r\n    7. 결과적으로 `6`을 반환한다.\r\n\r\n```jsx\r\n  const sumRange = (num) => {\r\n    if (num === 1) return 1; // 종료 조건\r\n    return num + sumRange(num - 1);\r\n  };\r\n\r\n// 콜 스택 과정\r\nsumRange(3) // 6\r\n    return 3 + sumRange(2) // 3 + 3\r\n                    return 2 + sumRange(1) // 2 + 1\r\n                                    return 1\r\n```\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"재귀 함수 예제"},{"data":{"title":"콜 스택 (Call Stack)","date":"2022-09-29","tags":["TIL","Udemy","콜 스택","호출 스택","Call Stack"],"draft":false,"summary":"콜 스택에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 콜 스택 (Call Stack)\r\n\r\n- 대부분의 프로그래밍 언어에서는 함수 호출을 관리하는 데이터 구조가 있다.\r\n- 자바스크립트에서 함수 호출을 관리하는 것이 `콜 스택`이다.\r\n- `콜 스택`은 자바스크립트의 보이지 않는 곳에서 작동하는 정적 데이터 구조이다.\r\n- 함수를 호출하게 되면 `콜 스택`에 스택이 쌓이게 되고 가장 위에 쌓인 함수부터 처리후 `콜 스택`에서 제거된다.\r\n- `콜 스택`에서 제거되는 조건은 함수가 종료되거나 `return`을 하게 되었을 떄이다.\r\n\r\n&nbsp;\r\n\r\n# 콜 스택이 동작하는 과정\r\n\r\n- 콜 스택의 과정을 보여주기 위해 작성한 코드 이다.\r\n- `trigger` 함수에 `breakpoint`를 걸고 우측의 `콜 스택` 블럭을 통해 진행 과정을 알아보자\r\n\r\n![trigger 함수 호출](/assets/posts/til/DS&Al/콜스택/01.png)\r\n\r\n&nbsp;\r\n\r\n## 1. trigger 함수 호출\r\n\r\n- 먼저 `trigger` 함수가 호출되면 콜 스택에 쌓인다.\r\n\r\n![trigger 함수를 콜 스택에 추가](/assets/posts/til/DS&Al/콜스택/02.png)\r\n\r\n&nbsp;\r\n\r\n## 2. firstFn 함수 호출\r\n\r\n- 이전에 호출된 `trigger` 함수에서 `firstFn` 함수를 호출\r\n- 콜 스택에 `firstFn` 함수가 쌓이게 된다.\r\n- 아직 `trigger` 함수는 끝나지 않은 상태임과 동시에 가장 먼저 호출된 함수이기 때문에 가장 아래에 위치해 있다.\r\n\r\n![firstFn 함수를 콜 스택에 추가](/assets/posts/til/DS&Al/콜스택/03.png)\r\n\r\n- 이후 `firstFn` 함수는 `return` 을 한다.\r\n\r\n![firstFn 함수에서 값을 return](/assets/posts/til/DS&Al/콜스택/04.png)\r\n\r\n- `return`을 했으니 콜 스택에서 `firstFn` 함수는 제거 된다.\r\n\r\n![firstFn 함수를 콜 스택에서 제거](/assets/posts/til/DS&Al/콜스택/05.png)\r\n\r\n&nbsp;\r\n\r\n## 3. secondFn 함수 호출\r\n\r\n- `trigger` 함수에서 `firstFn` 함수가 호출/제거 된 후, `secondFn` 함수를 호출하게되면 콜 스택에 쌓인다.\r\n- 이 때도 아직 `trigger` 함수는 끝나지 않았기 때문에 아직 콜 스택에 남아있다.\r\n\r\n![secondFn 함수를 콜 스택에 추가](/assets/posts/til/DS&Al/콜스택/06.png)\r\n\r\n\r\n- 이 후 `secondFn` 함수에서 `generateNumber` 함수를 호출하면 콜스택에 쌓인다.\r\n- 이 때 아직 `secondFn` 함수는 끝나지 않았기 때문에 콜스택에 남아있다.\r\n> 사진에서 generateNumnber -> generateNumber 로 오타 정정\r\n\r\n![secondFn 함수에서 값을 return](/assets/posts/til/DS&Al/콜스택/07.png)\r\n\r\n\r\n- `generateNumber` 함수가 `1`이란 값을 `return` 했기 때문에 종료 후 콜 스택에서 제거된다.\r\n\r\n![secondFn 함수를 콜 스택에서 제거](/assets/posts/til/DS&Al/콜스택/08.png)\r\n\r\n\r\n- 이후 secondFn 함수는 `generateNumber` 함수에서 `return`된 값 `1`을 가지고 `return`을 하게 된다.\r\n- 이렇게 `secondFn` 함수도 `return`한 후 콜 스택에서 제거된다.\r\n\r\n&nbsp;\r\n\r\n## 4. trigger 함수 종료\r\n\r\n- `secondFn` 함수도 종료/제거가 되면서 `trigger`함수는 마지막 남은 `console.log`를 띄운다.\r\n\r\n![trigger 함수에서 condole.log를 띄움](/assets/posts/til/DS&Al/콜스택/09.png)\r\n\r\n\r\n- `console.log`를 띄운 후 `trigger` 함수도 종료가 된다.\r\n\r\n![trigger 함수에서 띄운 log](/assets/posts/til/DS&Al/콜스택/10.png)\r\n\r\n![trigger 함수를 콜 스택에서 제거](/assets/posts/til/DS&Al/콜스택/11.png)\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"콜 스택 (Call Stack)"},{"data":{"title":"분할과 정복 패턴 (Divide and Conquer Pattern)","date":"2022-09-27","tags":["TIL","Udemy","Algorithm","분할과 정복 패턴","Divide and Conquer Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 분할과 정복 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 분할과 정복 패턴 (Divide and Conquer Pattern)\r\n\r\n- 주로 배열이나 문자열 같은 큰 규모의 데이터셋을 처리한다.\r\n- 이진 탐색이나 병합 정렬, 퀵 정렬 등에 사용되는 패턴이다.\r\n- 값을 찾기 위해 배열의 왼쪽에서 시작하여 오른쪽 끝까지 이동하는 것이 아닌 배열을 작은 조각으로 `세분`하여 각 조각들을 `어디로 이동`시킬지 결정하는 작업부터 시작한다.\r\n- 즉, 큰 데이터 덩어리를 작은 조각으로 나누는 거다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 정수로 이루어진 정렬된 배열과 찾으려는 값이 주어지면 배열에서 해당 값이 있는 인덱스(위치)를 반환하는 search라는 함수를 작성해라. 값을 찾을 수 없으면 -1을 반환한다.\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n)`\r\n- 선형 탐색\r\n- `arr`가 주어진다면 최대 `arr`의 길이만큼 반복해야 한다.\r\n\r\n```js\r\nconst search = (arr, val) => {\r\n\tfor(let i = 0; i < arr.length; i++) {\r\n\t\tif(arr[i] === val) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nsearch([1,2,3,4,5,6], 4) // 3\r\n```\r\n\r\n## 분할과 정복 패턴\r\n\r\n- 시간 복잡도 : `Log(n)`\r\n- 이진 탐색\r\n- 배열의 중간 값을 찾고나면 넘겨진 `val`이 속하는 배열을 골라 다시 중간 값을 찾고 `val`이 속한 배열을 골라서 `val`의 위치를 찾아낼 때까지 반복하는 작업\r\n\r\n```js\r\nconst search = (arr, val) => {\r\n  let min = 0;\r\n  let max = arr.length - 1;\r\n\r\n  while (min <= max) {\r\n\t\t// 배열의 중간 인덱스 (소수점 버림)\r\n    let middle = Math.floor((min + max) / 2);\r\n\r\n\t\t// 중간 인덱스의 값이 찾으려는 값보다 작으면\r\n\t\t// 찾으려는 값은 중간 인덱스의 값보다 큰 쪽에 속해 있다.\r\n\t\t// 증간 인덱스 보다 낮은 인덱스의 값들은 필요가 없으므로 min 값 갱신\r\n\t\t// e.g. 중간 인덱스의 값 = 3 / val = 4\r\n\t\t// 3이 4보다 작으니 3보다 작은 값들은 필요가 없다.\r\n    if (arr[middle] < val) {\r\n      min = middle + 1;\r\n    } else if (arr[middle] > val) {\r\n\t\t// 중간 인덱스의 값이 찾으려는 값보다 크면\r\n\t\t// 찾으려는 값은 중간 인덱스의 값보다 작은 쪽에 속해 있다.\r\n\t\t// 증간 인덱스 보다 큰 인덱스의 값들은 필요가 없으므로 max 값 갱신\r\n\t\t// e.g. 중간 인덱스의 값 = 7 / val = 4\r\n\t\t// 7이 4보다 크니 7보다 큰 값들은 필요가 없다.\r\n      max = middle - 1;\r\n    } else {\r\n        // 중간 인덱스의 값이 찾으려는 값과 같으면 바로 return\r\n        // e.g. 중간 인덱스의 값 = 4 / val = 4\r\n        // 중간 인덱스의 값이 찾으려는 값과 같으므로 위치 바로 return\r\n      return middle;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nsearch([1,2,3,4,5,6], 4) // 3\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"분할과 정복 패턴 (Divide and Conquer Pattern)"},{"data":{"title":"슬라이딩 윈도우 패턴 (Sliding Window Pattern)","date":"2022-09-26","tags":["TIL","Udemy","Algorithm","슬라이딩 윈도우 패턴","Sliding Window Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 슬라이딩 윈도우 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 슬라이딩 윈도우 패턴 (Sliding Window Pattern)\r\n\r\n- 위치를 조정할 수 있는 특정 길이의 가상의 `window`을 하나 설정한 후, ` window`의 위치를 좌에서 우 또는 우에서 좌로 이동시키면서 특정 조건을 만족하는 값을 찾아내는 것이다.\r\n- `window`는 단일 변수, 하위 배열, 또는 필요한 경우 다른 문자열도 될 수 있다.\r\n- 배열/문자열 등의 데이터를 입력하거나 특정 방식으로 연속적인 해당 데이터의 하위 집합을 찾는 경우에 유용하다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 배열과 숫자 하나를 전달 → 연속되는 n개의 숫자의 합계가 가장 큰 값을 구해라\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n^2)`\r\n- `for`문 을 이용한 이중 반복문\r\n\r\n```js\r\nconst max = (arr, n) => {\r\n    if (n > arr.length) return null;\r\n\r\n    // 배열이 만약 모두 음수로 구성되어 있다면 가장 큰합은 여전히 음수일 것이기 떄문이다.\r\n    // 전부 양수이지 않는한 0으로 설정하지 않는다.\r\n    let result = -Infinity;\r\n    for (let i = 0; i < arr.length - n + 1; i++){\r\n        temp = 0;\r\n        for (let j = 0; j < n; j++) {\r\n            temp += arr[i + j];\r\n        }\r\n        if(temp > result) {\r\n            result = temp;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//            v  v\r\nmax([1, 2, 5, 2, 8, 1, 5], 2) // 10\r\n```\r\n\r\n## 빈도  카운터 패턴\r\n\r\n- 시간 복잡도 : `O(n)`\r\n\r\n```js\r\nconst max = (arr, n) => {\r\n    let max = 0;\r\n    let temp = 0;\r\n    if(arr.length < n) return null;\r\n\r\n    // 맨 처음 0번에서 시작하는 n개의 합을 구해서 max로 설정\r\n    // e.g. 1, 2 의 합인 3을 초기 값으로 세팅\r\n    // [v  v]\r\n    // [1, 2, 5, 2, 8, 1, 5]\r\n    for(let i = 0; i < n; i++) {\r\n        max += arr[i]\r\n    }\r\n    temp = max;\r\n        // 그 다음부터는 맨 처음 설정한 max값을 for문들 돌면서 n개의 값을 더하는 게 아닌 위치를 window의 첫 위치의 값을 빼고 window의 다음 위치에 있는 값을 더한다.\r\n        //  - [v  +]             ->    [v  v]\r\n        // [1, 2, 5, 2, 8, 1, 5] -> [1, 2, 5, 2, 8, 1, 5]\r\n        // 그래서 그 값을 임시로 저장하고 기존 amx값과 비교해서 최대값을 갱신해 나간다.\r\n        // for문의 n값부터 시작한다.\r\n    for(let i = n; i < arr.length; i++) {\r\n        // 2 - 2 = 0번쨰 인덱스의 값을 뺴고 / 2번째 인덱스의 값을 더한다.\r\n        //  0 [1  2]\r\n        // [1, 2, 5, 2, 8, 1, 5]\r\n        temp = temp - arr[i - n] + arr[i];\r\n        max = Math.max(max, temp)\r\n    }\r\n    return max\r\n}\r\n\r\n//           [v  v]\r\nmax([1, 2, 5, 2, 8, 1, 5], 2) // 10\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"슬라이딩 윈도우 패턴 (Sliding Window Pattern)"},{"data":{"title":"다중 포인터 패턴 (Multiple Pointers Pattern)","date":"2022-09-24","tags":["TIL","Udemy","Algorithm","다중 포인터 패턴","Multiple Pointers Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 다중 포인터 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n&nbsp;\r\n\r\n# 1. 다중 포인터 패턴 (Multiple Pointers Pattern)\r\n\r\n- 인덱스나 위치에 해당하는 `포인터나 값`을 만든 다음 특정 조건에 따라 중간 지점에서부터 `시작 지점`이나 `끝 지점`이나 `양쪽 지점`을 향해 이동시킨다.\r\n- 두 개의 포인터를 지정하고 포인터의 위치를 변경하면서 `특정 조건에 맞는 쌍 or 값`을 찾는 것\r\n\r\n&nbsp;\r\n\r\n> e.g. 정렬된 배열을 취하는 `sumZero` 라는 함수 작성.\r\n오름차순으로 정렬되어 있어야 한다.\r\n처음으로 합해서 0이 되는 쌍을  찾으면 된다.\r\n\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n^2)`\r\n- 공간 복잡도 : `O(1)`\r\n- `for문`이중 반복문을 사용한다.\r\n\r\n```js\r\nconst sumZero = (arr) => {\r\n    for(const i in arr) {\r\n        for (const j in arr) {\r\n        // 합이 0이면 해당 값들 리턴\r\n        // 나올 때까지 돈다... 돌다가 나오면 리턴 아니면 끝까지 쭉 하고 undefined\r\n         if(arr[i] + arr[j] === 0) {\r\n             return [arr[i], arr[j]]\r\n         }\r\n        }\r\n    }\r\n};\r\nsumZero([-4, -3, -2, -1, 0 , 1, 2, 5]) // [-2, 2]\r\n```\r\n\r\n## 빈도  카운터 패턴\r\n\r\n- 시간 복잡도 : `O(n)`\r\n- 공간 복잡도 : `O(1)`\r\n- 양 끝에 인덱스를 포인터로 지정하고 합이 0에 맞는 값을 찾아나가는 과정이다.\r\n- 합이 0이 안된다면 좌, 우의 포인터를 한 칸씩 번갈아서 가운데 방향을 이동시키면서 합이 0이되는 인덱스의 값을 찾아낸다.\r\n\r\n```js\r\nconst sumZero = (arr) => {\r\n    let left = 0; // 배열의 첫번째 인덱스 지정\r\n    let right = arr.length - 1; // 배열의 끝 지점에 인덱스 지정\r\n\r\n    while(left < right) {\r\n      const sumNumber = arr[left] + arr[right];\r\n        // 합이 0이면 해당 값들 리턴\r\n        if(sumNumber === 0) {\r\n            return [arr[left], arr[right]]\r\n        // 합이 0보다 크면 우측 포지션 -1\r\n        } else if (arr[left] + arr[right] > 0) {\r\n            right--;\r\n        //합이 0보다 작거나 같으면 좌측 포지션 + 1\r\n        } else {\r\n            left++;\r\n        }\r\n    }\r\n};\r\n\r\nsumZero([-4, -3, -2, -1, 0 , 1, 2, 5])\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"다중 포인터 패턴 (Multiple Pointers Pattern)"},{"data":{"title":"빈도수 카운터 패턴 (Frequency Counters Pattern)","date":"2022-09-24","tags":["TIL","Udemy","Algorithm","빈도수 카운터 패턴","Frequency Counters Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 빈도수 카운터 패턴에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n# 1. 빈도수 카운터 패턴 (Frequency Counters Pattern)\r\n\r\n- 자바스크립트의 객체를 이용해서 값과 빈도수를 체크한다.\r\n- 두 개의 배열을 객체로 세분화하고 각 배열의 요소들을 분류하고 비교한다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 2개의 배열을 이용하는 same 함수가 있다. 두번째 배열의 값들은 첫번쨰 배열의 값들의 제곱이다. 각 값들의 빈도 수가 같아야한다.\r\n\r\n\r\n## 일반적인 패턴 `O(n^2)`\r\n\r\n- `for문`과 `indexOf`메소드를 이용한 이중 반복문\r\n\r\n```js\r\nconst same = (first, second) => {\r\n    // 두 배열의 길이가 다르면 false\r\n    if (first.length !== second.length) return false;\r\n    for (const i in first) {\r\n        // 두번째 배열에 매칭되는 인덱스 찾기\r\n        const correct = second.indexOf(first[i] ** 2);\r\n        // 없으면 false\r\n        if (correct === -1) return false;\r\n        // 있으면 체크 후 제거\r\n        second.splice(correct, 1);\r\n    }\r\n    return true;\r\n  };\r\n\r\nsame([1, 2, 3, 2], [4, 1, 9, 4])\r\n```\r\n\r\n## 빈도  카운터 패턴 `O(n)`\r\n\r\n- 이중 반복문을 돌리는 대신 각 배열을 한번씩만 반복문 적용\r\n- 이중 반복문보다 빠르다.\r\n- 두 객체를 사용해서 각 배열 `value`의 빈도수를 체크 (`value`가 각 배열에서 몇 번 나왔는지 알 수 있다.)\r\n- 만둘어진 객체의 `key`를 체크하는 반복문을 작성해서 하나의 객체에만 적용시켜주면 된다. (여기서는 `frequencyCounter1`)\r\n```js\r\nconst same = (first, second) => {\r\n    if (first.length !== second.length) return false;\r\n    let frequencyCounter1 = {}; // {1: 1, 2: 2, 3: 1}\r\n    let frequencyCounter2 = {}; // {1: 1, 4: 2, 9: 1}\r\n    for (const val of first) {\r\n        // 없으면 1로, 있으면 1씩 더함\r\n        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;\r\n    }\r\n    for (const val of second) {\r\n        // 없으면 1로, 있으면 1씩 더함\r\n        frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;\r\n    }\r\n    for (const key in frequencyCounter1) {\r\n        // 매칭되는 key가 있는지 체크\r\n        if (!(key ** 2 in frequencyCounter2)) {\r\n            return false;\r\n        }\r\n        // 해당 key를 이용해서 매칭되는 value의 빈도수가 같은지 체크\r\n        if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    // 모든 조건 통과시 true\r\n    return true;\r\n  };\r\n\r\nsame([1, 2, 3, 2], [4, 1, 9, 4])\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"빈도수 카운터 패턴 (Frequency Counters Pattern)"},{"data":{"title":"빅오로 보는 배열과 객체의 성능 평가","date":"2022-09-22","tags":["TIL","Udemy","Data Structure","빅오","Big O","Object","Array"],"draft":false,"summary":"배열과 객체 그리고 내장된 메소드들의 성능은?","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n# 1. 객체(Object)의 빅오(Big O)\r\n\r\n- 객체는 정렬되어 있지 않다.\r\n- 저장, 접근, 제거, 수정의 경우 `O(1)`이 걸린다.\r\n- 탐색은 단순하게 `key`에 접근하는 것이 아닌 `value`를 가져와야하기에 `O(n)`이 걸린다.\r\n\r\n    ```js\r\n     const obj = { name: \"jack\", age: 0 };\r\n    // 'jack' 이라는 값이 어디에 저장되어 있는가를 알기위해서는 모든 `key`값을 돌며 `value`를 체크해야한다.\r\n    ```\r\n\r\n- `Object.keys, Object.values, Object.entries` 메소드들의 경우 `O(n)`이 걸린다.\r\n    - 객체를 돌며 다 배열에 담아 반환해야하기 떄문이다.\r\n- `hasOwnProperty`의 경우 `O(1)`이 걸린다.\r\n    - `key`가 있는지 없는지 바로 접근이 가능하기 때문이다.\r\n\r\n&nbsp;\r\n\r\n# 2. 배열(Array)의 빅오(Big O)\r\n\r\n- 배열은 정렬된 데이터이다. 그렇기에 각 값에 인덱스가 붙어있다.\r\n\r\n- 접근의 경우 `O(1)`이 걸린다.\r\n    - `index`로 바로 접근하면 되기 때문이다.\r\n\r\n- 탐색은 객체와 동일하게 `O(n)`이 걸린다.\r\n\r\n- 저장의 경우 어디에 저장하느냐에 따라 빅오가 달라진다.\r\n    - `push`메소드는 배열의 끝에 저장하기 때문에 `O(1)`이 걸린다.\r\n    - `unshift`메소드는 배열의 처음에 저장하기 때문에 `O(n)`이 걸린다.\r\n\r\n- 제거의 경우도 어디를 제거하느냐에 따라 빅오가 달라진다.\r\n  - `pop` 메소드는 배열의 끝값을 제거하기 때문에 `O(1)`이 걸린다.\r\n  - `shift`메소드는 배열의 처음값을 제거하기 때문에 `O(n)`이 걸린다.\r\n\r\n&nbsp;\r\n\r\n## 왜? 같은 저장, 제거인데 다르죠?\r\n\r\n- 인덱스 번호의 재배치 때문이다.\r\n- 배열의 끝에 `저장/제거`하는 경우는 끝에 값이 있기 때문에 다른 값들의 인덱스는 변화가 없다.\r\n- 하지만 배열의 처음에 `저장/제거`하는 경우는 그 작업을 수행한 후 나머지 값들의 인덱스를 재배치 해주어야하기 때문이다.\r\n\r\n    ```js\r\n    // 기존의 0번 인덱스에 위치한 값은 \"A\"이지만 shift 호출이후 \"B\"로 바뀌게 된다.\r\n    // 즉, 0번 인덱스의 값이 제거가 되면 나머지 값들의 인덱스 번호가 하나씩 떙겨져 재배치 된다.\r\n    const arr = [\"A\", \"B\", \"C\", \"D\"];\r\n    arr[0] // \"A\"\r\n    arr.shift()\r\n    arr[0] // \"B\"\r\n    ```\r\n\r\n- 비어있는 배열의 경우를 제외하고 `push, pop`메소드는 `shift, unshift`보다 빠르다.\r\n- `push, pop`메소드의 경우`O(1)`이 걸린다.\r\n- `shift, unshift, concat, slice, splice`메소드의 경우 `O(n)`이 걸린다.\r\n- `sort`메소드의 경우 `O(n* log n)`이 걸린다. (추후 포스팅)\r\n- `forEach, map, filter, reduce`메소드의 경우 `O(n)`이 걸린다.\r\n\r\n\r\n---\r\n\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"빅오로 보는 배열과 객체의 성능 평가"},{"data":{"title":"빅오 표기법 (Big O Notation)","date":"2022-09-18","tags":["TIL","Data Structure","빅오","Big O"],"draft":false,"summary":"빅오 표기법에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n# 1. 빅오 (Big O) 소개\r\n\r\n- `효율성` 체크을 위해 알고리즘 성능을 측정하고 비교한다.\r\n- `input` 값의 증가에 따라 알고리즘의 실행 시간이 어떻게 변하는지에 대해 설명하는 공식적인 방법\r\n- `입력 값의 크기`와 `실행시간의 관계`를 나타낸다.\r\n- `전반적인 추세`에 주목한다.\r\n\r\n# 2. 코드 시간 재기\r\n\r\n- 더 나은 코드의 기준은 뭘까 ? => 속도? 가독성? 메모리 사용량?\r\n- 보통 시간에 집중을 한다. 시간이 중요하지만 단순 시간 측정은 기기의 성능에 차이가 난다.\r\n    그렇다고해서 똑같은 기기에서는 동일하냐? 그것도 아니다.\r\n    똑같은 기기에서도 시간 측정 기록은 차이가 있다.\r\n\r\n- 매번 새로운 방법이 나왔을 때 그것을 측정하는 것도 비용이다\r\n- 그래서 나온것이 빅오이다.\r\n\r\n# 3. 연산 갯수 세기\r\n\r\n- 코드가 실행될 때 걸리는 정확한 시간을 초로 측정하는 것보다는 → 컴퓨터가 처리해야하는 `연산의 갯수`를 세면된다.\r\n- 연산의 정확한 갯수를 세는 것보다는 `전체적인 추세`를 아는 것이 목적이다.\r\n- n값이 커질수록 연산의 갯수도 늘어나는 것은 당연하다. 이렇게 n값에 따른 변화 추이를 그래프로 그렸을 때 해당 알고리즘의 추세를 알 수 있다.\r\n\r\n![시간 복잡도 도식화 @50%](/assets/posts/til/DS&Al/빅오/01.png)\r\n\r\n# 6. 빅오 표현식의 단순화하기\r\n\r\n- 항상 같은 연산 = `O(1)` 실행 시간에 변함이 없다. n이 커져도 같다.\r\n- 선형 관계 (1:1) = `O(n)` n이 커지면 실행시간도 커진다.\r\n\r\n### 실행 시간\r\n1. 산수 = `O(1)`  (+ -  / *)\r\n2. 변수 할당 = `O(1)`\r\n3. 인덱스를 이용해 배열 엘리먼트에 접근 = `O(1)`\r\n4. 키를 통해 오브젝트 엘리먼트에 접근 = `O(1)`\r\n5. 루프 ⇒ 루프 길이에 따라\r\n\r\n```tsx\r\n// 무조건 반목문이 들어간다고 해서 최소 O(n)은 아니다.\r\n// 로직을 어떻게 짜느냐에 따라 다르다.\r\n// 예외\r\n\r\nfunction logAtMost5(n) {\r\n\tfor (let i = 1; i <= Math.min(5, n); i++) {\r\n\t\tconsole.log(i);\r\n\t}\r\n}\r\n\r\nlogAtMost5(1); // 1\r\nlogAtMost5(3); // 1 2 3\r\nlogAtMost5(5); // 1 2 3 4 5\r\nlogAtMost5(10); // 1 2 3 4 5\r\nlogAtMost5(100000); // 1 2 3 4 5\r\n\r\n// 추세를 보면 n값이 커져도 항상 5를 넘지 않는다\r\n// 5미만의 n 값들은 n값의 커짐에 따라 별로 영향을 주지 않는다\r\n// 그렇기에 빅오는 O(1)이다.\r\n```\r\n\r\n# 7. 공간 복잡도\r\n\r\n- 시간 복잡도 → 입력값(n)에 따른 알고리즘의 실행 속도\r\n- 입력값(n)이 커질수록 알고리즘이 얼마나 많은 공간을 차지하는지 고려한다. (메모리 사용량)\r\n- 입력되는 것을 제외하고 알고리즘 자체가 필요로 하는 공간\r\n\r\n1. 원시값들 `(boolean, numbers, undefined, null)`\r\n    - `상수 공간(constant space), O(1)`, 항상 똑같은 공간을 차지 = 불변 공간\r\n2. `String, Reference type, array, object` = `O(n) space`\r\n    - string → 문자의 길이\r\n    - array → 배열의 길이.\r\n    - object → 키의 갯수\r\n- 공간은 입력의 크기에 따른 리턴값 간의 관계\r\n\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"빅오 표기법 (Big O Notation)"}]},"__N_SSG":true}