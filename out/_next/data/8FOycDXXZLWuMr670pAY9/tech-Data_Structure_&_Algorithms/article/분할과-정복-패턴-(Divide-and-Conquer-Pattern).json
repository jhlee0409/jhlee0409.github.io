{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":9},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":{"title":"분할과 정복 패턴 (Divide and Conquer Pattern)","date":"2022-09-27","tags":["TIL","Udemy","Algorithm","분할과 정복 패턴","Divide and Conquer Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 분할과 정복 패턴에 대해 알아보자"},"content":"\r\n&nbsp;\r\n\r\n# 1. 분할과 정복 패턴 (Divide and Conquer Pattern)\r\n\r\n- 주로 배열이나 문자열 같은 큰 규모의 데이터셋을 처리한다.\r\n- 이진 탐색이나 병합 정렬, 퀵 정렬 등에 사용되는 패턴이다.\r\n- 값을 찾기 위해 배열의 왼쪽에서 시작하여 오른쪽 끝까지 이동하는 것이 아닌 배열을 작은 조각으로 `세분`하여 각 조각들을 `어디로 이동`시킬지 결정하는 작업부터 시작한다.\r\n- 즉, 큰 데이터 덩어리를 작은 조각으로 나누는 거다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 정수로 이루어진 정렬된 배열과 찾으려는 값이 주어지면 배열에서 해당 값이 있는 인덱스(위치)를 반환하는 search라는 함수를 작성해라. 값을 찾을 수 없으면 -1을 반환한다.\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n)`\r\n- 선형 탐색\r\n- `arr`가 주어진다면 최대 `arr`의 길이만큼 반복해야 한다.\r\n\r\n```js\r\nconst search = (arr, val) => {\r\n\tfor(let i = 0; i < arr.length; i++) {\r\n\t\tif(arr[i] === val) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nsearch([1,2,3,4,5,6], 4) // 3\r\n```\r\n\r\n## 분할과 정복 패턴\r\n\r\n- 시간 복잡도 : `Log(n)`\r\n- 이진 탐색\r\n- 배열의 중간 값을 찾고나면 넘겨진 `val`이 속하는 배열을 골라 다시 중간 값을 찾고 `val`이 속한 배열을 골라서 `val`의 위치를 찾아낼 때까지 반복하는 작업\r\n\r\n```js\r\nconst search = (arr, val) => {\r\n  let min = 0;\r\n  let max = arr.length - 1;\r\n\r\n  while (min <= max) {\r\n\t\t// 배열의 중간 인덱스 (소수점 버림)\r\n    let middle = Math.floor((min + max) / 2);\r\n\r\n\t\t// 중간 인덱스의 값이 찾으려는 값보다 작으면\r\n\t\t// 찾으려는 값은 중간 인덱스의 값보다 큰 쪽에 속해 있다.\r\n\t\t// 증간 인덱스 보다 낮은 인덱스의 값들은 필요가 없으므로 min 값 갱신\r\n\t\t// e.g. 중간 인덱스의 값 = 3 / val = 4\r\n\t\t// 3이 4보다 작으니 3보다 작은 값들은 필요가 없다.\r\n    if (arr[middle] < val) {\r\n      min = middle + 1;\r\n    } else if (arr[middle] > val) {\r\n\t\t// 중간 인덱스의 값이 찾으려는 값보다 크면\r\n\t\t// 찾으려는 값은 중간 인덱스의 값보다 작은 쪽에 속해 있다.\r\n\t\t// 증간 인덱스 보다 큰 인덱스의 값들은 필요가 없으므로 max 값 갱신\r\n\t\t// e.g. 중간 인덱스의 값 = 7 / val = 4\r\n\t\t// 7이 4보다 크니 7보다 큰 값들은 필요가 없다.\r\n      max = middle - 1;\r\n    } else {\r\n        // 중간 인덱스의 값이 찾으려는 값과 같으면 바로 return\r\n        // e.g. 중간 인덱스의 값 = 4 / val = 4\r\n        // 중간 인덱스의 값이 찾으려는 값과 같으므로 위치 바로 return\r\n      return middle;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nsearch([1,2,3,4,5,6], 4) // 3\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다."},"__N_SSG":true}