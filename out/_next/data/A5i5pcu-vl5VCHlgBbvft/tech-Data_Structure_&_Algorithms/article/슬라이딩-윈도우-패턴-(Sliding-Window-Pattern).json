{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":10},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":{"title":"슬라이딩 윈도우 패턴 (Sliding Window Pattern)","date":"2022-09-26","tags":["TIL","Udemy","Algorithm","슬라이딩 윈도우 패턴","Sliding Window Pattern"],"draft":false,"summary":"여러 문제해결 패턴 중 슬라이딩 윈도우 패턴에 대해 알아보자"},"content":"\r\n&nbsp;\r\n\r\n# 1. 슬라이딩 윈도우 패턴 (Sliding Window Pattern)\r\n\r\n- 위치를 조정할 수 있는 특정 길이의 가상의 `window`을 하나 설정한 후, ` window`의 위치를 좌에서 우 또는 우에서 좌로 이동시키면서 특정 조건을 만족하는 값을 찾아내는 것이다.\r\n- `window`는 단일 변수, 하위 배열, 또는 필요한 경우 다른 문자열도 될 수 있다.\r\n- 배열/문자열 등의 데이터를 입력하거나 특정 방식으로 연속적인 해당 데이터의 하위 집합을 찾는 경우에 유용하다.\r\n\r\n&nbsp;\r\n\r\n> e.g. 배열과 숫자 하나를 전달 → 연속되는 n개의 숫자의 합계가 가장 큰 값을 구해라\r\n\r\n## 일반적인 패턴\r\n- 시간 복잡도 : `O(n^2)`\r\n- `for`문 을 이용한 이중 반복문\r\n\r\n```js\r\nconst max = (arr, n) => {\r\n    if (n > arr.length) return null;\r\n\r\n    // 배열이 만약 모두 음수로 구성되어 있다면 가장 큰합은 여전히 음수일 것이기 떄문이다.\r\n    // 전부 양수이지 않는한 0으로 설정하지 않는다.\r\n    let result = -Infinity;\r\n    for (let i = 0; i < arr.length - n + 1; i++){\r\n        temp = 0;\r\n        for (let j = 0; j < n; j++) {\r\n            temp += arr[i + j];\r\n        }\r\n        if(temp > result) {\r\n            result = temp;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//            v  v\r\nmax([1, 2, 5, 2, 8, 1, 5], 2) // 10\r\n```\r\n\r\n## 빈도  카운터 패턴\r\n\r\n- 시간 복잡도 : `O(n)`\r\n\r\n```js\r\nconst max = (arr, n) => {\r\n    let max = 0;\r\n    let temp = 0;\r\n    if(arr.length < n) return null;\r\n\r\n    // 맨 처음 0번에서 시작하는 n개의 합을 구해서 max로 설정\r\n    // e.g. 1, 2 의 합인 3을 초기 값으로 세팅\r\n    // [v  v]\r\n    // [1, 2, 5, 2, 8, 1, 5]\r\n    for(let i = 0; i < n; i++) {\r\n        max += arr[i]\r\n    }\r\n    temp = max;\r\n        // 그 다음부터는 맨 처음 설정한 max값을 for문들 돌면서 n개의 값을 더하는 게 아닌 위치를 window의 첫 위치의 값을 빼고 window의 다음 위치에 있는 값을 더한다.\r\n        //  - [v  +]             ->    [v  v]\r\n        // [1, 2, 5, 2, 8, 1, 5] -> [1, 2, 5, 2, 8, 1, 5]\r\n        // 그래서 그 값을 임시로 저장하고 기존 amx값과 비교해서 최대값을 갱신해 나간다.\r\n        // for문의 n값부터 시작한다.\r\n    for(let i = n; i < arr.length; i++) {\r\n        // 2 - 2 = 0번쨰 인덱스의 값을 뺴고 / 2번째 인덱스의 값을 더한다.\r\n        //  0 [1  2]\r\n        // [1, 2, 5, 2, 8, 1, 5]\r\n        temp = temp - arr[i - n] + arr[i];\r\n        max = Math.max(max, temp)\r\n    }\r\n    return max\r\n}\r\n\r\n//           [v  v]\r\nmax([1, 2, 5, 2, 8, 1, 5], 2) // 10\r\n```\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다."},"__N_SSG":true}