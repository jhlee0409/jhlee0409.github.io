{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":14},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":{"title":"이진 탐색 (Binary Search)","date":"2022-10-06","tags":["TIL","Udemy","Algorithm","이진 탐색","Binary Search"],"draft":false,"summary":"이진 탐색에 대해 알아보자"},"content":"\r\n&nbsp;\r\n\r\n# 이진 탐색 (Binary Search)\r\n\r\n- 기본적인 개념은 분할 정복 패턴을 사용한다.\r\n  - 배열의 중간점을 찾고, 중간점을 기준으로 찾으려는 값이 속한 집단을 선택, 값을 찾을 때까지 반복\r\n- 한 번 체크할 때 배열의 탐색해야할 요소들을 절반 줄일 수 있다.\r\n- 조건은 배열이 분류되어 있어야 한다는 것이다\r\n    > e.g. 숫자 : 오름차순, 내림차순, 문자열 : abc순, ㄱㄴㄷ순\r\n\r\n\r\n&nbsp;\r\n\r\n# 이진 탐색의 의사코드 (Pseudocode)\r\n\r\n- 정렬된 배열과 `value`를 인자로 받는 함수이다.\r\n- 배열의 시작점을 나타내는 포인터(좌측)와, 배열의 끝을 나타내는 포인터(우측)를 정한다.\r\n- 시작점의 포인터의 값이 끝지점의 포인터보다 크거나 같아질 때까지 연산을 계속한다.\r\n  - 중간점을 찾는다\r\n  - 만약 중간점이 `value`와 같다면 `index`를 리턴한다.\r\n  - `value`보다 중간점이 더 작다면 좌측 포인터의 값을 올린다.\r\n  -` value`보다 중감점이 더 크다면 우측 포인터의 값을 내린다.\r\n  - 원하는 `value`를 찾지 못했다면 `-1`을 리턴한다.\r\n\r\n&nbsp;\r\n\r\n## 이진 탐색 구현\r\n\r\n- 시간 복잡도 : `O(log n)`\r\n- `log 16 = 4`이고 `log 32 = 5`이다.\r\n- `log 16`에서 `16`은 배열의 길이라고 한다면 `4`는 원하는 값을 찾는 작업의 수라고 보면된다.\r\n- 길이가 `16`인 배열에서 중간점을 찾고 원하는 값이 속한 집단을 찾고 이 작업을 `4번`만 반복하면 된다는 뜻이다.\r\n- 배열의 길이가 배로 늘어남에 따라 값을 찾기 위해 찾는 작업을 한 번만 더 하면 되기 때문이다.\r\n\r\n```jsx\r\nconst binarySearch = (arr, value) => {\r\n    let left = 0;\r\n    let right = arr.length - 1;\r\n    let middle = Math.floor((left + right) / 2);\r\n\r\n    while(arr[middle] !== value  && left <= right) {\r\n        if(value > arr[middle]) left = middle + 1;\r\n        else right = middle - 1;\r\n        middle = Math.floor((left + right) / 2);\r\n    }\r\n    return arr[middle] === value ? middle : -1;\r\n}\r\n\r\nbinarySearch([1,2,3,4,5],2) // 1\r\nbinarySearch([1,2,3,4,5],3) // 2\r\nbinarySearch([1,2,3,4,5],5) // 4\r\nbinarySearch([1,2,3,4,5],6) // -1\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n#### 피드백은 언제나 환영입니다."},"__N_SSG":true}