{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":11},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"[Typescript] tsconfig 절대경로 설정하기","date":"2022-09-15","tags":["TIL","Typescript","tsconfig.json","jsconfig.json","Absolute paths"],"draft":false,"summary":"tsconfig.json 설정을 통해 절대경로를 설정해보자","mainCategory":"tech","subCategory":"typescript"},"content":"\r\n# 서론\r\n- 특정 컴포넌트나 파일을 `import`할 시 경로의 `depth`가 깊어지면 깊어질수록 `import`하려는 파일의 위치에 따라 `상대경로`가 상당히 길어질 수 있다.\r\n```javascript\r\n// 극단적인 예\r\nimport deep from '../../../../../../../A/B/C/file.js';\r\n\r\n// 이런게 수없이 많다면?\r\nimport deep1 from '../../../../../../../A/B/C/file1.js';\r\nimport deep2 from '../../../../../../../A/B/C/file2.js';\r\nimport deep3 from '../../../../../../../A/B/C/file3.js';\r\nimport deep4 from '../../../../../../../A/B/C/file4.js';\r\nimport deep5 from '../../../../../../../A/B/C/file5.js';\r\n...\r\n...\r\nimport deep999 from '../../../../../../../A/B/C/file5.js';\r\n```\r\n- 이런 식으로 상대경로가 길어지면 `import`할 파일을 찾기위한 수고가 커질 뿐더라 가독성 면에서도 좋지 않다.\r\n- `tsconfig.json` or `jsconfig.json`의 설정을 통해 `절대경로`를 설정할 수 있다\r\n\r\n# tsconfig.json 이란?\r\n- `typscript`에 대한 설정을 할 수 있는 파일이며 `javascript`로 이루어진 레포지토리라면 `jsconfig.json`을 사용한다.\r\n- 해당 레포지토리가 `Typescript`를 사용하고 있다면 루트 디렉토리에 `tsconfig.json`이 존재해야며 `tsc`명령어를 통한 컴파일시 로드한다.\r\n- 컴파일러에 대한 옵션 설정과 더불어 다양한 기능을 제공한다.\r\n```json\r\n// tsconfig.json 의 예시\r\n{\r\n  \"compilerOptions\": {\r\n    ...\r\n  },\r\n  \"include\": [...],\r\n  \"exclude\": [...]\r\n}\r\n```\r\n\r\n## 절대경로 설정하기\r\n- `tsconifg.json`에서 `compilerOptions` 옵션의 `baseUrl`과 `paths`를 이용해서 `절대경로`를 설정한다.\r\n- `baseUrl`의 경우 `paths`를 설정하기 위해서는 반드시 설정해야하는 옵션이다.\r\n- `paths`의 경우 `key-value`쌍으로 이루어진 객체이며 절대경로를 정의하고자 하는 경로의 이름을 `key`에 입력하며 `baseUrl`을 기준으로 상대적인 경로를 `value`에 입력한다.\r\n- `paths`의 `key`에는 주로 `@`으로 시작을 하며 바로 다음으로 `/, _` 같은 특수문자를 넣는데 이유는 `@`로 시작하는 패키지가 종종 있기 떄문이다.\r\n```json\r\n// tsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\", // 이 경우는 tsconfig.json이 존재하는 루트 디렉토리를 기준으로 삼는다.\r\n    \"paths\": {\r\n      \"@_components/*\": [\"src/components/*\"],\r\n      \"@_apis/*\": [\"src/api/*\"],\r\n      \"@_types/*\": [\"src/types/*\"],\r\n      \"@_icons/*\": [\"public/assets/icons/*\"],\r\n      \"@_images/*\": [\"public/assets/images/*\"],\r\n      \"@_emojis/*\": [\"public/assets/emoji/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n- 위와 같은 `paths`를 지정한다면 실제로 루트 디렉토리를 기준으로한 구조는 다음과 같다\r\n```text\r\nRoot\r\n├─ public\r\n│   └─ assets\r\n│      ├─ icons\r\n│      ├─ images\r\n│      └─ emojis\r\n└─ src\r\n     ├─ components\r\n     ├─ api\r\n    └─ types\r\n```\r\n- 실제로 적용된 예시를 보자\r\n```typescript\r\nimport path1 from '@_components/home/main.tsx';\r\nimport path2 from '@_icons/sample.png';\r\nimport path2 from '@_apis/member'\r\n```\r\n- 특정 파일뿐만 아니라 모듈도 `절대경로`로 지정이 가능하다.\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n# 추가\r\n\r\n- 절대경로를 추가하는 `paths`가 늘어나면 따로 빼놓는 것도 가능하다.\r\n- `tsconfig.json`의 `extends`옵션을 이용한다.\r\n- 기본 `config` 파일을 읽어온 후 `extends`에 지정한 파일에 의해 오버라이딩(overridden) 된다.\r\n- `include`나 `exclude`에 정의한 파일의 경우 기본 `config` 파일을 덮어쓴다.(overwrite)\r\n- `extends` 옵션은 스트링값으로만 받는다.\r\n- 여러 설정 파일을 `extend`하고 싶다면 줄줄이 이어받는 구조를 만들어야한다.\r\n    ```json\r\n    // tsconfig.a.json\r\n    {\r\n      \"compilerOptions\": {\r\n        ...\r\n      },\r\n    }\r\n    ```\r\n  ```json\r\n  // tsconfig.b.json\r\n  {\r\n    \"compilerOptions\": {\r\n      ...\r\n    },\r\n    \"extends\": \"./tsconfig.a.json\"\r\n  }\r\n    ```\r\n  ```json\r\n  // tsconfig.json\r\n  {\r\n    \"compilerOptions\": {\r\n      ...\r\n    },\r\n    \"extends\": \"./tsconfig.b.json\"\r\n  }\r\n    ```\r\n\r\n## 사용법\r\n- 위에 설정한 파일을 따로 만들어 저장해둔다.\r\n- 파일명은 어떤식으로 지어도 상관없으며, 어느 디렉토리에 속해도 된다. `json`형식이면 된다.\r\n- 아래의 경우 `tsconfig.path.json`을 루트 디렉토리에 만든다.\r\n\r\n```json\r\n// tsconfig.paths.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"@_components/*\": [\"src/components/*\"],\r\n      \"@_apis/*\": [\"src/api/*\"],\r\n      \"@_types/*\": [\"src/types/*\"],\r\n      \"@_icons/*\": [\"public/assets/icons/*\"],\r\n      \"@_images/*\": [\"public/assets/images/*\"],\r\n      \"@_emojis/*\": [\"public/assets/emoji/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n- `tsconfig.json`에 `extends`옵션을 추가한 뒤 확장하고자하는 `json`을 파일을 `tsconifg.json`을 기준으로한` 상대경로`로 입력해준다.\r\n```json\r\n// tsconifg.json\r\n{\r\n  \"compilerOptions\": {\r\n    ...\r\n  },\r\n  \"extends\": \"./tsconfig.paths.json\"\r\n}\r\n```\r\n\r\n\r\n\r\n#\r\n\r\n### 참조\r\n- [TSConfig Reference](https://www.typescriptlang.org/tsconfig)\r\n- [Documentation - What is a tsconfig.json](https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html)\r\n\r\n#\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"[Typescript] tsconfig 절대경로 설정하기"},{"data":{"title":"Typescript Section5","date":"2022-04-01","tags":["TIL","TypeScript","Udemy"],"draft":false,"summary":"Section 5 클래스 & 인터페이스","mainCategory":"tech","subCategory":"typescript"},"content":"\r\n# Section 5 : 클래스 & 인터페이스\r\n\r\n## 57. 모듈 소개\r\n\r\n## 58. 클래스란무엇인가\r\n\r\n## 59. 퍼스트 클래스 만들기\r\n\r\n## 60. 자바스크립트로 컴파일하기\r\n\r\n## 61. 생성자 함수 및 “this” 키워드\r\n\r\n## 62. 개인 및 “공용” 액세스 수정자\r\n\r\n## 63. 약식 초기화\r\n\r\n## 64. “읽기전용” 속성\r\n\r\n## 65. 상속\r\n\r\n- **KEYWORD : class** ExtraClass **extends** BaseClass **{…}**\r\n- 공통적인 기능을 공유하면서 특수화된 청사진을 생성할 수 있다.\r\n- 기본 클래스를 설정한 다음 이를 상속하는 특수화된 클래스 생성 가능\r\n\r\n## 66. 속성 및 “보호된” 수정자 재정의\r\n\r\n## 67. 게터 & 세터\r\n\r\n## 68. 정적 메서드 & 속성\r\n\r\n- 정적 메소드 : 클래스를 기반으로 생성된 객첵 X ⇒ 클래스에서 직접 호출하드 메소드\r\n\r\n## 69. 추상클래스\r\n\r\n- **KEYWORD : abstract Class & (private method or private property)**\r\n- 상속 받는 클래스에서 abstract를 매긴 메소드가 필히 구현되어야할 때 정의\r\n- 공통 메소드 or 속성을 공유하도록 하려는 경우 유용\r\n- abstract할 메소드와 해당 메소드가 속한 클래스 앞에 abstract 추가\r\n- abstract 메소드에는 리턴타입도 명시\r\n- 추상 클래스는 기본적으로 상속되어야 할 클래스일 뿐\r\n- 인스턴스화 할 수 없고 확정되어야 한다.\r\n\r\n```tsx\r\nabstract Class Sample {\r\n\tabstract value:number = 0; //property\r\n\tabstract Add(): void; //method\r\n}\r\n```\r\n\r\n## 70. 싱글톤 & 개인 생성자\r\n\r\n1. 싱글톤\r\n\r\n   - **KEYWORD : private constructor**\r\n   - 특정 클래스의 인스턴스를 정확히 하나만 갖도록 한다\r\n   - “new”로 생성하지 않고 메소드를 호출하여 구성 ⇒ 특정 시점에 반드시 하나의 클래스 인스턴스가 존재한다.\r\n   - 정적 메소드 or 속성을 사용할 수 없거나 사용하지 않고자 하는 동시에 클래스를 기반으로 여러 객체를 만들 수는 없지만 항상 클래스를 기반으로 정확히 하나의 객체만 가질 수 있도록 하고자 하는 경우에 유용\r\n\r\n   ```tsx\r\n   class OnlyOne {\r\n     private constructor() {}\r\n     private static instance: OnlyOne;\r\n     //! SOLUTION\r\n     // 인스턴스를 가지고 있다면 이를 반환 아니면 새 인스턴스 생성\r\n     static getInstance() {\r\n       if (OnlyOne.instance) {\r\n         return this.instance;\r\n       }\r\n       this.instance = new OnlyOne();\r\n       return this.instance;\r\n     }\r\n   }\r\n\r\n   //! ERROR\r\n   const one = new OnlyOne();\r\n\r\n   //! RESULT\r\n   const one = OnlyOne.getInstance();\r\n   const one2 = OnlyOne.getInstance();\r\n   ```\r\n\r\n## 71. 클래스 - 요약\r\n\r\n## 72. 인터페이스\r\n\r\n- **KEYWORD : interface**\r\n- 객체의 구조를 설명한다.\r\n- 초기값 할당 불가, 구체적인 값X, 구조만 있을 뿐\r\n- 해당 인터페이스의 구조를 가져야 하는 객체의 타입을 확인하는 타입으로 사용\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n  age: number; //age: number = 15; !ERROR 값 할당 시\r\n  greet(phase: string): void; // return nothing!\r\n}\r\n\r\nlet user1: Person;\r\n\r\n// 인터페이스의 정의를 충족하는 올바른 객체\r\nuser1 = {\r\n  name: \"Lee\",\r\n  age: 27,\r\n  greet(phrse: string) {\r\n    consle.log(phrase + \" \" + thi.name);\r\n  },\r\n};\r\n\r\nuser1.greet(\"Hi there - I am\");\r\n// result => Hi there - I am Lee\r\n```\r\n\r\n## 73. 클래스와 인터페이스 사용하기\r\n\r\n- **KEYWORD :** **Class** Sample **implements** TestInterface {}\r\n- What is different between type and interface\r\n  1. 인터페이스는 객체의 구조를 설명하기 위해서만 사용한다는 것이다.\r\n  2. 이 경우에도 타입 사용은 가능하지만\r\n     사용자 정의 타입 대신 유니온 타입 등을 저장할 수도 있다.\r\n  3. 인터페이스를 자주 사용하는 이유\r\n     - 클래스가 인터페이스를 이행하고 준수해야 하는 약속처럼 사용할 수 있기 때문\r\n- 상속은 한 클래스로부터만 상속할 수 있지만 인터페이스는 “,”로 구분하여 여러개 구현 가능\r\n- 인터페이스는 주로 구체적인 구현이 아닌 서로 다른 클래스 간의 기능을 공유하기 위해 사용됨\r\n- 인터페이스 내 ⇒ 구현 or 값을 입력하는 게 아닌 ⇒ 구조와 클래스가 가져야할 기능을 입력\r\n- 추상 클래스로 작업하는 것과 다소 비슷\r\n  - 인터페이스 ⇒ 구현 세부 사항이 전혀 없다\r\n  - 추상 클래스 ⇒ 덮어써야 했던 부분과 본인이 수행한 구체적 구현 부분을 혼합할 수 있다.\r\n- 인터페이스를 어떤 상수나 변수의 타입으로 사용하여 인터페이스 타입을 기반으로 하는 다른 타입의 다른 클래스를 저장할 수 있다. ⇒ inplements 덕분\r\n\r\n```tsx\r\ninterface Greetable {\r\n  name: string;\r\n  greet(phase: string): void; // return nothing!\r\n}\r\n\r\n// extends(상속)와 달리 여러 개의 인터페이스 적용 가능 / \",\"로 구분하여 추가\r\nclass Person implements Greetable, Sample {\r\n  name: string;\r\n  age = 30; // 추가 가능\r\n  constructor(n: string) {\r\n    this.name = n;\r\n  }\r\n\r\n  greet(phase: string) {\r\n    consle.log(phrase + \" \" + thi.name);\r\n  }\r\n}\r\n// Greetable 타입도 가능하고 Person 타입으로도 지정 가능\r\n// Why? Person 객체도 결국 Greetable 인터페이스에 기반한 것이기 때문\r\nlet user1: Greetable;\r\n\r\nuser1 = new Person(\"Lee\");\r\nuser1.greet(\"Hi there - I am\");\r\n// result => Hi there - I am Lee\r\n```\r\n\r\n## 74. 왜 인터페이스인가\r\n\r\n- 메소드의 경우\r\n  - 인터페이스에 해당 메소드를 정의해두면\r\n  - implements하는 모든 클래스들이 인터페이스 내의 메소드를 구현하게 해야할 경우\r\n- 인터페이스를 사용하여 특정 구조를 구현\r\n-\r\n\r\n```tsx\r\n// user1에 무엇을 저장하는 Greetable이어야하고\r\n// 객체나 클래스에 대한 모든 것을 알 필요가 없는 강력하고 유연한  코드를 작성할 수 있지만\r\n// user1에는 greet 메소드가 있어야 한다는 것은 알 수 있다.\r\nlet user1: Greetable;\r\n// Person이 여기서 무엇을 갖고 있든 상관없다. greet만 관건\r\nuser1 = new Person(\"Lee\");\r\nuser1.greet(\"Hi there - I am\");\r\n```\r\n\r\n## 75. 읽기 전용 인터페이스 속성\r\n\r\n- **KEYWORD : readonly in interface**\r\n- public, private 등은 지정할 수 없다.\r\n- readonly를 추가 ⇒ 인터페이스를 기반으로 구축하는 모든 객체의 property가 한 번만 설정 ⇒ 이후 읽기 전용으로 설정 ⇒ 객체가 초기화되면 변경할 수 없도록 할 수 있다.\r\n\r\n```tsx\r\ninterface Greetable {\r\n\treadonly name: string;\r\n\tgreet(phase: string): void; // return nothing!\r\n}\r\n\r\nclass Person implements Greetable, Sample {\r\n// 클래스 내에서 readonly를 지정하지 않아도 Greetable을 구현해야하는 것을 인지\r\n// => name이 읽기 전용임을 자동으로 추론하기 떄문\r\n// Why? 인터페이스 안에서 그렇게 설정했기 때문\r\n\tname: string;\r\n\t ...\r\n}\r\n\r\nlet user1: Greetable ;\r\nuser1 = new Person('Lee')\r\n//! ERROR 일기 전용이기 때문, 처음에만 셋업\r\nuser1.name = 'Kim'\r\n```\r\n\r\n## 76. 인터페이스 확장하기\r\n","path":"Typescript Section5"}]},"__N_SSG":true}