{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":8},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"[Programming] 프레임워크와 라이브러리의 차이","date":"2022-09-20","tags":["TIL","Programming","Framework","Library"],"draft":false,"summary":"프레임워크와 라이브러리의 차이에 대해 알아보자","mainCategory":"tech","subCategory":"programming"},"content":"\r\n# 서론\r\n\r\n- 흔히 프로그래밍을 하는 사람이라면 한번 쯤 들어보고 생각해봤을 주제이다.\r\n- 이 부분에 대해 깊게 관심을 가지는 사람들도 있는 반면 자연스럽게 스쳐지나갔을 수도 있다.\r\n- 본인들이 사용하는 기술들의 사이트를 방문해보면 이게 라이브러리인지 프레임워크인지 명시가 되어있다.\r\n- 그렇다면 왜 각 기술들은 라이브러리? 프레임워크? 비슷해보이지만 다른 둘, 어떤 기준으로 정하는 것일까?\r\n- 바로 그러면 프레임워크와 라이브러리가 어떤 것인지 그리고 차이점은 뭔지 알아보자.\r\n\r\n&nbsp;\r\n\r\n> e.g. Frontend\r\n\r\n![좌측 상단부터 React, Vue,js, Next.js, Recoil](/assets/posts/til/Programming/framework&library/05.png)\r\n\r\n\r\n\r\n# 프레임워크(Framework)란?\r\n\r\n> 한줄 설명: 일정한 틀 안에서 틀이 정한 일정한 규칙에 따라 작성해야한다.\r\n\r\n- 프레임워크는 그들이 제공하는 규칙과 가이드라인이 있으며 사용자는 이에 맞게 코드를 작성해 나가야한다.\r\n- 규칙과 가이드라인을 벗어나서 코드를 작성하면 정상적으로 동작하지 않을 수 있다.\r\n\r\n&nbsp;\r\n\r\n# 라이브러리(Library)란?\r\n\r\n> 한줄 설명: 여러 기능들을 담은 말그대로 도서관! 내가 원하는 것만 골라 꺼내 쓸 수 있다.\r\n\r\n- 라이브러리의 제작자가 코드를 작성해 기능을 만들고 그것들을 모듈화 해놓은 것이다.\r\n- 해당 라이브러리에서 만들어놓은 컴포넌트나 메소드, 등을 내가 원하는 곳에서 내가 원할 때 그리고 내가 필요한 것들을 호출해 가져다 쓰기만 하면된다.\r\n- 본인이 따로 커스텀할 수 있는 옵션이 있다면 그것 또한 라이브러리에서 제공하는 기능이므로 내가 필요할 때 옵션을 넣기만하면 된다.\r\n- 기본적으로 호출해서 바로 쓸 수 있다.\r\n\r\n&nbsp;\r\n\r\n# 공통점\r\n\r\n- 재사용 가능하다.\r\n\r\n    - 라이브러리의 경우 어디서나 내가 원할 떄 호출이 가능하니 호출이 즉 재사용을 의미한다.\r\n    - 프레임워크의 경우 흐름에 맞춰 본인이 작성해놓은 코드를 원하는 곳에서 호출이 가능하다.\r\n\r\n&nbsp;\r\n\r\n# 차이점\r\n\r\n1. 사용의 주도권을 누가 쥐고 있느냐\r\n\r\n    - 프레임워크 : 프레임워크 자체가 쥐고 있으며 사용자는 프레임워크가 제시한 규칙에 따라 코드를 작성해야한다.\r\n    - 라이브러리 : 사용자가 쥐고 있으며, 사용자는 자신이 원하는 기능만 호출해 사용하면 된다.\r\n\r\n&nbsp;\r\n\r\n2. 프레임워크는 라이브러리를 포함한다.\r\n\r\n    - 프레임워크는 코드를 작성함에 있어서 필요한 라이브러리(기능)들을 제공해 줄 수 있다.\r\n\r\n![출처는 참고링크](/assets/posts/til/Programming/framework&library/06.png)\r\n\r\n&nbsp;\r\n\r\n3. 라이브러리도 정해진 규칙에 따라 호출해야하는 게 아닌가요?\r\n\r\n    - 필자가 생각하는 가장 큰 차이점은 호출 즉시 바로 사용할 수 있느냐 이다.\r\n\r\n    > e.g. 내가 A라는 기능을 원하는 경우\r\n\r\n    - 라이브러리의 경우 찾아서 A 기능을 쓰면 된다.\r\n    - 프레임워크의 경우 A 기능을 프레임워크에서 제공한 방식에 따라 직접 구현한다. A 기능을 제공한다면 그건 프레임워크의 라이브러리이다.\r\n    - 프레임워크에서 제공하는 기능들 때문에 이게 프레임워크인지 라이브러리인지 헷갈릴 수도 있다.\r\n\r\n\r\n&nbsp;\r\n\r\n4. 내가 지금 작성하고 있는 코드가 근간이 되는 언어에서 기반이 된건지 아니면 프레임워크나 라이브러리가 기반이 되는지 잘 보아야한다.\r\n\r\n    > e.g. React와 Vue.js에서 반복문을 쓰는 경우\r\n\r\n    - React\r\n\r\n    ```jsx\r\n    // React의 경우 반복문의 구현자체는 자바스크립트의 반복문을 사용하는 것이다.\r\n    // map이 아니더라도 for-in, for-of, for 다양하게 사용해서 구현 가능하다.\r\n    // map 사용\r\n    <div id=\"list-rendering\">\r\n      <ol>\r\n         {todos.map((todo)=> {\r\n             return (\r\n                 <li key={todo.id} >{todo.text}</li>\r\n             )\r\n         })}\r\n      </ol>\r\n    </div>\r\n    ```\r\n   &nbsp;\r\n\r\n    - Vue.js\r\n\r\n    ```vue\r\n    // 반드시 vue 에서 정한 규칙에 따라 반복문을 구현해야한다.\r\n    <div id=\"list-rendering\">\r\n      <ol>\r\n        <li v-for=\"todo in todos\">\r\n          {{ todo.text }}\r\n        </li>\r\n      </ol>\r\n    </div>\r\n    ```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n### 참고\r\n- [What is the difference between a framework and a library?](https://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library)\r\n\r\n\r\n---\r\n\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"[Programming] 프레임워크와 라이브러리의 차이"},{"data":{"title":".env 파헤치기","date":"2022-08-26","tags":["TIL","Programming",".env","Environment Variables"],"draft":false,"summary":"React, Next 에서의 .env","mainCategory":"tech","subCategory":"programming"},"content":"# 1. CRA에서의 .env\n- CRA(Creat React App)에서는 `.env`를 어떻게 써야할까\n- 기본적으로 환경 변수를 사용할 수 있도록 세팅되어있다.\n- 변수를 선언해서 사용 가능\n- 선언하려는 변수 명에 `prefix`로  `REACT_APP_` 을 붙여줘야하며 그러지 않을 시 `모두 무시`된다.\n- `REACT_APP_` 이외에도 `NODE_ENV`라는 기본적으로 제공되는 환경 변수도 있다.\n- `NODE_ENV`는 현재 서버 환경을 나타낸다.\n- `NODE_ENV`로 서버 환경별 조건부 실행이 가능하다.\n- `.env` 파일을 수정하면 서버를 재실행 시켜야 변경사항이 반영된다.\n- `.env`에서 선언한 변수는 `process.env`에서 불러온다.\n- `.gitignore`에 `.env`파일들을 추가해 외부에 노출시키지 않도록한다.\n\n## 1-1. 사용법\n\n- 기본\n```jsx\n//.env\nREACT_APP_CLIENT_URL='...'\n// file.js\nprocess.env.REACT_APP_CLIENT_URL\n```\n- `NODE_ENV`의 경우\n```jsx\nprocess.env.NODE_ENV // 환경별로 'development', 'production', 'test'\n```\n- `HTML`의 경우\n```html\n// file.html\n<p>%REACT_APP_CLIENT_URL%</p>\n```\n\n## 1-2. 각 .env 파일 로드 시점\n\n```jsx\n.env.env : 기본 파일\n.env.local : 로컬 설정 오버라이딩. test를 제외한 모든 환경에서 불러와짐\n.env.development : 개발 환경에서 불러와짐\n.env.test : test 환경에서 불러와짐\n.env.production : 빌드된 배포 환경에서 불러와짐\n.env.production.local, .env.test.local, .env.production.local : 환경별 로컬 설정 오버라이딩\n```\n\n## 1-3. 환경별 .env 파일 로드 우선순위\n- 왼쪽이 오른쪽보다 우선순위가 높다.\n\n```jsx\nnpm start: .env.development.local > .env.local > .env.development > .env\nnpm run build: .env.production.local > .env.local > .env.production > .env\nnpm test: .env.test.local > .env.test > .en\n```\n\n## 1-4. 환경 변수 확장\n- `dot-env-expand`를 사용하면 확장 가능\n\n```jsx\nDOMAIN=www.example.com\nREACT_APP_FOO=$DOMAIN/foo\nREACT_APP_BAR=$DOMAIN/bar\n```\n\n#\n\n# 2. Next.js에서의 .env\n\n- 환경 변수를 기본적으로 사용할 수 있도록 세팅되어 있다.\n- `.env.local`로 환경 변수 로드\n- 기본적으로 Node.js 환경에서만 사용 가능하며, 브라우저에 노출이 되지 않지만 `GA 추적코드`와 같은 외부에 노출되어야 하는 변수의 경우 `prefix`로 `NEXT_PUBLIC_`을 붙인다.\n\n## 2-1. 사용법\n- 기본\n```jsx\n//.env.local\nDB_HOST='sample-host'\n// file.js\nprocess.env.DB_HOST\n```\n- 외부 노출의 경우\n```jsx\n// 노출하고 싶으면\nNEXT_PUBLIC_GA_ID='gagaga'\n// file.js\nprocess.env.NEXT_PUBLIC_GA_ID\n```\n\n#\n\n- `process.env`는 js 객체가 아니므로 `구조 분해 할당` 사용 불가\n\n```jsx\n// 불가\nconst { DB_HOST } = process.env;\n```\n\n#\n\n- `$SOME_VALUE`를 통해 확장 가능\n```jsx\n// .env\nHOSTNAME=localhost\nPORT=8080\nHOST=http://$HOSTNAME:$PORT\n```\n\n#\n\n- `$`의 실제 값을 사용하고 싶으면 `\\` 이용\n```jsx\nNAME='jack'\n\nA=MY_NAME_IS$NAME // result =  MY_NAME_ISjack\nB=MY_NAME_IS\\$NAME // result = MY_NAME_ISNAME\n```\n\n## 2-2. 환경 변수 로드 순서\n- 맞는 환경 변수를 찾으면 중단\n1. `process.env`\n2. `.env.production.local`, `.env.development.local`, `.env.test.local`\n3. `.env.local` (test 환경에서는 생략)\n4. `.env.production`, `.env.development`, `.env.test`\n5. `.env`\n\n#\n\n#### 참조\n- [Next.js ENV](https://nextjs.org/docs/basic-features/environment-variables#loading-environment-variables)\n- [CRA ENV](https://create-react-app.dev/docs/adding-custom-environment-variables/#what-other-env-files-can-be-used)\n\n#\n\n#### 피드백은 언제나 환영입니다.","path":".env 파헤치기"},{"data":{"title":"네이밍 컨벤션 파헤치기","date":"2022-08-20","tags":["TIL","Programming","Naming Convention"],"draft":false,"summary":"Naming Convention, Pascal, Camel, Snake, Kebab, Hungarian","mainCategory":"tech","subCategory":"programming"},"content":"# 네이밍 컨벤션 파헤치기\r\n## 네이밍 컨벤션 종류\r\n- 각 영단어에 대한 네이밍에 대해 여러 종류가 있다\r\n1. 카멜 케이스 (camelCase)\r\n2. 파스칼 케이스 (PascalCase)\r\n3. 스네이크 케이스 (snake_case)\r\n4. 케밥 케이스 (kebab-case)\r\n5. 헝가리언 표기법 (Hungarian Notation)\r\n\r\n## WHY?\r\n- 이러한 네이밍 컨벤션이 왜 필요할까?\r\n- 위의 컨벤션들은 모두 영어 합성어에 대한 기법이다.\r\n- 프로그래밍에서 여러 언어들은 각각 정해놓은 명령어와 선언방식이 있고 그걸 따르기 위해서 띄어쓰기를 이용한다.\r\n  그렇기에 띄어쓰기를 하게되면 여러 단어를 하나로 묶어 표현할 수 없게된다.\r\n- 그렇다고 모든 영단어를 띄어쓰기 없이 소문자로 적게되면\r\n  가독성이 떨어질 뿐더러 특수한 상황(e.g. class의 이름)에서의 명명을 소문자로 하게된다면 오류를 범하게 된다.\r\n\r\n\r\n- 이러한 여러 컨벤션들은 각 팀의 합의 하에 정해진다\r\n- 각 케이스가 어떠한 경우에 사용되는지 또 어떻게 사용하는지 알아보자\r\n\r\n## 사용법\r\n- 기본적으로 영어합성어에서 표기하는 기법\r\n1. 카멜케이스\r\n    - 유래\r\n        - 쌍봉낙타의 등과 비슷하게 생겨서 붙여진 이름\r\n    -  주로 `파일, 변수, 함수` 등 대상의 이름을 `띄어쓰기 없이` 짓는다.\r\n    - 합성어에서 기본적으로 소문자로 적되, `첫 단어를 제외`한 모든 단어의 `첫 글자는 대문자`로 표기한다.\r\n    - e.g. camelCase, isOpen, setState, namingConvention\r\n\r\n2. 파스칼 케이스\r\n    - 유래\r\n        - 파스칼 언어에서 사용하던 표기법이어서 붙여진 이름\r\n    - 주로 `클래스` 등 대상의 이름을 `띄어쓰기 없이` 짓는다.\r\n    - 합성어에서 기본적으로 소문자로 적되, 모든 단어의 `첫 글자는 대문자`로 표기한다.\r\n    - e.g. PascalCase, MyClass, MyComponent, NamingConvention\r\n\r\n3. 스네이크 케이스\r\n    - 유래\r\n        - 뱀의 형태와 비슷하게 생겨서 붙여진 이름\r\n    - 주로 `파일, 변수, 함수, 상수` 등 각 단어를 띄어쓰기 대신 `_`로 이어 붙여 짓는다.\r\n    - e.g. snake_case, is_open, ENUM_TYPE, naming_convention\r\n\r\n4. 케밥 케이스\r\n    - 유래\r\n        - 케밥 꼬챙이의 모습과 비슷하게 생겨서 붙여진 이름\r\n    - 주로 `url` 등 각 단어를 띄어쓰기 대신 `-`로 이어 붙여 짓는다.\r\n    - e.g. kebab-case, is-open, set-state, naming-convention\r\n\r\n5. 헝가리언 케이스\r\n    - 유래\r\n        - 해당 표기법을 만든 사람이 헝가리인이어서 붙여진 이름\r\n    - 변수명 앞에 `데이터 타입`을 붙여 짓는다.\r\n    - 타입이 바뀌면 변수명도 바뀌어야 하는 문제 때문에 이제는 지양하는 방향\r\n    - e.g. int -> iNumber, str -> strName\r\n\r\n\r\n\r\n\r\n#### 참조\r\n- [카멜 표기법 ](https://ko.wikipedia.org/wiki/%EC%B9%B4%EB%A9%9C_%ED%91%9C%EA%B8%B0%EB%B2%95)\r\n- [스네이크 표기법](https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%84%A4%EC%9D%B4%ED%81%AC_%ED%91%9C%EA%B8%B0%EB%B2%95)\r\n- [Case Styles: Camel, Pascal, Snake, and Kebab Case](https://betterprogramming.pub/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841)\r\n- [카멜, 파스칼, 스네이크, 헝가리안, 케밥 표기법 정리](https://needjarvis.tistory.com/632)\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"네이밍 컨벤션 파헤치기"}]},"__N_SSG":true}