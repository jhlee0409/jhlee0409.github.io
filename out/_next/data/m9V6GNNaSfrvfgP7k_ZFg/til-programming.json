{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":3}]},{"title":"tech","sub":[{"title":"refactoring","count":3},{"title":"typescript","count":1}]},{"title":"til","sub":[{"title":"AWS","count":1},{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Google Analytics 4","count":1},{"title":"HTML","count":1},{"title":"javascript","count":3},{"title":"markdown","count":1},{"title":"programming","count":2},{"title":"react","count":2}]}],"data":[{"data":{"title":".env 파헤치기","date":"2022-08-26","tags":["TIL","Programming",".env","Environment Variables"],"draft":false,"summary":"React, Next 에서의 .env","mainCategory":"til","subCategory":"programming"},"content":"# 1. CRA에서의 .env\n- CRA(Creat React App)에서는 `.env`를 어떻게 써야할까\n- 기본적으로 환경 변수를 사용할 수 있도록 세팅되어있다.\n- 변수를 선언해서 사용 가능\n- 선언하려는 변수 명에 `prefix`로  `REACT_APP_` 을 붙여줘야하며 그러지 않을 시 `모두 무시`된다.\n- `REACT_APP_` 이외에도 `NODE_ENV`라는 기본적으로 제공되는 환경 변수도 있다.\n- `NODE_ENV`는 현재 서버 환경을 나타낸다.\n- `NODE_ENV`로 서버 환경별 조건부 실행이 가능하다.\n- `.env` 파일을 수정하면 서버를 재실행 시켜야 변경사항이 반영된다.\n- `.env`에서 선언한 변수는 `process.env`에서 불러온다.\n- `.gitignore`에 `.env`파일들을 추가해 외부에 노출시키지 않도록한다.\n\n## 1-1. 사용법\n\n- 기본\n```jsx\n//.env\nREACT_APP_CLIENT_URL='...'\n// file.js\nprocess.env.REACT_APP_CLIENT_URL\n```\n- `NODE_ENV`의 경우\n```jsx\nprocess.env.NODE_ENV // 환경별로 'development', 'production', 'test'\n```\n- `HTML`의 경우\n```html\n// file.html\n<p>%REACT_APP_CLIENT_URL%</p>\n```\n\n## 1-2. 각 .env 파일 로드 시점\n\n```jsx\n.env.env : 기본 파일\n.env.local : 로컬 설정 오버라이딩. test를 제외한 모든 환경에서 불러와짐\n.env.development : 개발 환경에서 불러와짐\n.env.test : test 환경에서 불러와짐\n.env.production : 빌드된 배포 환경에서 불러와짐\n.env.production.local, .env.test.local, .env.production.local : 환경별 로컬 설정 오버라이딩\n```\n\n## 1-3. 환경별 .env 파일 로드 우선순위\n- 왼쪽이 오른쪽보다 우선순위가 높다.\n\n```jsx\nnpm start: .env.development.local > .env.local > .env.development > .env\nnpm run build: .env.production.local > .env.local > .env.production > .env\nnpm test: .env.test.local > .env.test > .en\n```\n\n## 1-4. 환경 변수 확장\n- `dot-env-expand`를 사용하면 확장 가능\n\n```jsx\nDOMAIN=www.example.com\nREACT_APP_FOO=$DOMAIN/foo\nREACT_APP_BAR=$DOMAIN/bar\n```\n\n#\n\n# 2. Next.js에서의 .env\n\n- 환경 변수를 기본적으로 사용할 수 있도록 세팅되어 있다.\n- `.env.local`로 환경 변수 로드\n- 기본적으로 Node.js 환경에서만 사용 가능하며, 브라우저에 노출이 되지 않지만 `GA 추적코드`와 같은 외부에 노출되어야 하는 변수의 경우 `prefix`로 `NEXT_PUBLIC_`을 붙인다.\n\n## 2-1. 사용법\n- 기본\n```jsx\n//.env.local\nDB_HOST='sample-host'\n// file.js\nprocess.env.DB_HOST\n```\n- 외부 노출의 경우\n```jsx\n// 노출하고 싶으면\nNEXT_PUBLIC_GA_ID='gagaga'\n// file.js\nprocess.env.NEXT_PUBLIC_GA_ID\n```\n\n#\n\n- `process.env`는 js 객체가 아니므로 `구조 분해 할당` 사용 불가\n\n```jsx\n// 불가\nconst { DB_HOST } = process.env;\n```\n\n#\n\n- `$SOME_VALUE`를 통해 확장 가능\n```jsx\n// .env\nHOSTNAME=localhost\nPORT=8080\nHOST=http://$HOSTNAME:$PORT\n```\n\n#\n\n- `$`의 실제 값을 사용하고 싶으면 `\\` 이용\n```jsx\nNAME='jack'\n\nA=MY_NAME_IS$NAME // result =  MY_NAME_ISjack\nB=MY_NAME_IS\\$NAME // result = MY_NAME_ISNAME\n```\n\n## 2-2. 환경 변수 로드 순서\n- 맞는 환경 변수를 찾으면 중단\n1. `process.env`\n2. `.env.production.local`, `.env.development.local`, `.env.test.local`\n3. `.env.local` (test 환경에서는 생략)\n4. `.env.production`, `.env.development`, `.env.test`\n5. `.env`\n\n#\n\n#### 참조\n- [Next.js ENV](https://nextjs.org/docs/basic-features/environment-variables#loading-environment-variables)\n- [CRA ENV](https://create-react-app.dev/docs/adding-custom-environment-variables/#what-other-env-files-can-be-used)\n\n#\n\n#### 피드백은 언제나 환영입니다.","path":".env 파헤치기"},{"data":{"title":"네이밍 컨벤션 파헤치기","date":"2022-08-20","tags":["TIL","Programming","Naming Convention"],"draft":false,"summary":"Naming Convention, Pascal, Camel, Snake, Kebab, Hungarian","mainCategory":"til","subCategory":"programming"},"content":"# 네이밍 컨벤션 파헤치기\r\n## 네이밍 컨벤션 종류\r\n- 각 영단어에 대한 네이밍에 대해 여러 종류가 있다\r\n1. 카멜 케이스 (camelCase)\r\n2. 파스칼 케이스 (PascalCase)\r\n3. 스네이크 케이스 (snake_case)\r\n4. 케밥 케이스 (kebab-case)\r\n5. 헝가리언 표기법 (Hungarian Notation)\r\n\r\n## WHY?\r\n- 이러한 네이밍 컨벤션이 왜 필요할까?\r\n- 위의 컨벤션들은 모두 영어 합성어에 대한 기법이다.\r\n- 프로그래밍에서 여러 언어들은 각각 정해놓은 명령어와 선언방식이 있고 그걸 따르기 위해서 띄어쓰기를 이용한다.\r\n  그렇기에 띄어쓰기를 하게되면 여러 단어를 하나로 묶어 표현할 수 없게된다.\r\n- 그렇다고 모든 영단어를 띄어쓰기 없이 소문자로 적게되면\r\n  가독성이 떨어질 뿐더러 특수한 상황(e.g. class의 이름)에서의 명명을 소문자로 하게된다면 오류를 범하게 된다.\r\n\r\n\r\n- 이러한 여러 컨벤션들은 각 팀의 합의 하에 정해진다\r\n- 각 케이스가 어떠한 경우에 사용되는지 또 어떻게 사용하는지 알아보자\r\n\r\n## 사용법\r\n- 기본적으로 영어합성어에서 표기하는 기법\r\n1. 카멜케이스\r\n    - 유래\r\n        - 쌍봉낙타의 등과 비슷하게 생겨서 붙여진 이름\r\n    -  주로 `파일, 변수, 함수` 등 대상의 이름을 `띄어쓰기 없이` 짓는다.\r\n    - 합성어에서 기본적으로 소문자로 적되, `첫 단어를 제외`한 모든 단어의 `첫 글자는 대문자`로 표기한다.\r\n    - e.g. camelCase, isOpen, setState, namingConvention\r\n\r\n2. 파스칼 케이스\r\n    - 유래\r\n        - 파스칼 언어에서 사용하던 표기법이어서 붙여진 이름\r\n    - 주로 `클래스` 등 대상의 이름을 `띄어쓰기 없이` 짓는다.\r\n    - 합성어에서 기본적으로 소문자로 적되, 모든 단어의 `첫 글자는 대문자`로 표기한다.\r\n    - e.g. PascalCase, MyClass, MyComponent, NamingConvention\r\n\r\n3. 스네이크 케이스\r\n    - 유래\r\n        - 뱀의 형태와 비슷하게 생겨서 붙여진 이름\r\n    - 주로 `파일, 변수, 함수, 상수` 등 각 단어를 띄어쓰기 대신 `_`로 이어 붙여 짓는다.\r\n    - e.g. snake_case, is_open, ENUM_TYPE, naming_convention\r\n\r\n4. 케밥 케이스\r\n    - 유래\r\n        - 케밥 꼬챙이의 모습과 비슷하게 생겨서 붙여진 이름\r\n    - 주로 `url` 등 각 단어를 띄어쓰기 대신 `-`로 이어 붙여 짓는다.\r\n    - e.g. kebab-case, is-open, set-state, naming-convention\r\n\r\n5. 헝가리언 케이스\r\n    - 유래\r\n        - 해당 표기법을 만든 사람이 헝가리인이어서 붙여진 이름\r\n    - 변수명 앞에 `데이터 타입`을 붙여 짓는다.\r\n    - 타입이 바뀌면 변수명도 바뀌어야 하는 문제 때문에 이제는 지양하는 방향\r\n    - e.g. int -> iNumber, str -> strName\r\n\r\n\r\n\r\n\r\n#### 참조\r\n- [카멜 표기법 ](https://ko.wikipedia.org/wiki/%EC%B9%B4%EB%A9%9C_%ED%91%9C%EA%B8%B0%EB%B2%95)\r\n- [스네이크 표기법](https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%84%A4%EC%9D%B4%ED%81%AC_%ED%91%9C%EA%B8%B0%EB%B2%95)\r\n- [Case Styles: Camel, Pascal, Snake, and Kebab Case](https://betterprogramming.pub/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841)\r\n- [카멜, 파스칼, 스네이크, 헝가리안, 케밥 표기법 정리](https://needjarvis.tistory.com/632)\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"네이밍 컨벤션 파헤치기"}]},"__N_SSG":true}