{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":1},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"[Programming] 프레임워크와 라이브러리의 차이","date":"2022-09-20","tags":["TIL","Programming","Framework","Library"],"draft":false,"summary":"프레임워크와 라이브러리의 차이에 대해 알아보자","mainCategory":"tech","subCategory":"programming"},"content":"\r\n# 서론\r\n\r\n- 흔히 프로그래밍을 하는 사람이라면 한번 쯤 들어보고 생각해봤을 주제이다.\r\n- 이 부분에 대해 깊게 관심을 가지는 사람들도 있는 반면 자연스럽게 스쳐지나갔을 수도 있다.\r\n- 본인들이 사용하는 기술들의 사이트를 방문해보면 이게 라이브러리인지 프레임워크인지 명시가 되어있다.\r\n- 그렇다면 왜 각 기술들은 라이브러리? 프레임워크? 비슷해보이지만 다른 둘, 어떤 기준으로 정하는 것일까?\r\n- 바로 그러면 프레임워크와 라이브러리가 어떤 것인지 그리고 차이점은 뭔지 알아보자.\r\n\r\n&nbsp;\r\n\r\n> e.g. Frontend\r\n\r\n![좌측 상단부터 React, Vue,js, Next.js, Recoil](/assets/posts/til/Programming/framework&library/05.png)\r\n\r\n\r\n\r\n# 프레임워크(Framework)란?\r\n\r\n> 한줄 설명: 일정한 틀 안에서 틀이 정한 일정한 규칙에 따라 작성해야한다.\r\n\r\n- 프레임워크는 그들이 제공하는 규칙과 가이드라인이 있으며 사용자는 이에 맞게 코드를 작성해 나가야한다.\r\n- 규칙과 가이드라인을 벗어나서 코드를 작성하면 동작하는데 오류가 발생한다.\r\n\r\n&nbsp;\r\n\r\n# 라이브러리(Library)란?\r\n\r\n> 한줄 설명: 여러 기능들을 담은 말그대로 도서관! 내가 원하는 것만 골라 꺼내 쓸 수 있다.\r\n\r\n- 라이브러리의 제작자가 코드를 작성해 기능을 만들고 그것들을 모듈화 해놓은 것이다.\r\n- 해당 라이브러리에서 만들어놓은 컴포넌트나 메소드, 등을 내가 원하는 곳에서 내가 원할 때 그리고 내가 필요한 것들을 호출해 가져다 쓰기만 해면된다.\r\n- 본인이 따로 커스텀할 수 있는 옵션이 있다면 그것 또한 라이브러리에서 제공하는 기능이므로 내가 필요할 때 옵션을 넣기만하면 된다.\r\n- 기본적으로 호출해서 바로 쓸 수 있다.\r\n\r\n&nbsp;\r\n\r\n# 공통점\r\n\r\n- 재사용 가능하다.\r\n\r\n    - 라이브러리의 경우 어디서나 내가 원할 떄 호출이 가능하니 호출이 즉 재사용을 의미한다.\r\n    - 프레임워크의 경우 흐름에 맞춰 본인이 작성해놓은 코드를 원하는 곳에서 호출이 가능하다.\r\n\r\n&nbsp;\r\n\r\n# 차이점\r\n\r\n1. 사용의 주도권을 누가 쥐고 있느냐\r\n\r\n    - 프레임워크 : 프레임워크 자체가 쥐고 있으며 사용자는 프레임워크가 제시한 규칙에 따라 코드를 작성해야한다.\r\n    - 라이브러리 : 사용자가 쥐고 있으며, 사용자는 자신이 원하는 기능만 호출해 사용하면 된다.\r\n\r\n&nbsp;\r\n\r\n2. 프레임워크는 라이브러리를 포함한다.\r\n\r\n    - 프레임워크는 코드를 작성함에 있어서 필요한 라이브러리(기능)들을 제공해 줄 수 있다.\r\n\r\n![출처는 참고링크](/assets/posts/til/Programming/framework&library/06.png)\r\n\r\n&nbsp;\r\n\r\n3. 라이브러리도 정해진 규칙에 따라 호출해야하는 게 아닌가요?\r\n\r\n    - 필자가 생각하는 가장 큰 차이점은 호출 즉시 바로 사용할 수 있느냐 이다.\r\n\r\n    > e.g. 내가 A라는 기능을 원하는 경우\r\n\r\n    - 라이브러리의 경우 찾아서 A 기능을 쓰면 된다.\r\n    - 프레임워크의 경우 A 기능을 프레임워크에서 제공한 방식에 따라 직접 구현한다. A 기능을 제공한다면 그건 프레임워크의 라이브러리이다.\r\n    - 프레임워크에서 제공하는 기능들 때문에 이게 프레임워크인지 라이브러리인지 헷갈릴 수도 있다.\r\n\r\n\r\n&nbsp;\r\n\r\n4. 내가 지금 작성하고 있는 코드가 근간이 되는 언어에서 기반이 된건지 아니면 프레임워크나 라이브러리가 기반이 되는지 잘 보아야한다.\r\n\r\n    > e.g. React와 Vue.js에서 반복문을 쓰는 경우\r\n\r\n    - React\r\n\r\n    ```jsx\r\n    // React의 경우 반복문의 구현자체는 자바스크립트의 반복문을 사용하는 것이다.\r\n    // map이 아니더라도 for-in, for-of, for 다양하게 사용해서 구현 가능하다.\r\n    // map 사용\r\n    <div id=\"list-rendering\">\r\n      <ol>\r\n         {todos.map((todo)=> {\r\n             return (\r\n                 <li key={todo.id} >{todo.text}</li>\r\n             )\r\n         })}\r\n      </ol>\r\n    </div>\r\n    ```\r\n   &nbsp;\r\n\r\n    - Vue.js\r\n\r\n    ```vue\r\n    // 반드시 vue 에서 정한 규칙에 따라 반복문을 구현해야한다.\r\n    <div id=\"list-rendering\">\r\n      <ol>\r\n        <li v-for=\"todo in todos\">\r\n          {{ todo.text }}\r\n        </li>\r\n      </ol>\r\n    </div>\r\n    ```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n### 참고\r\n- [What is the difference between a framework and a library?](https://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library)\r\n\r\n\r\n---\r\n\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"[Programming] 프레임워크와 라이브러리의 차이"},{"data":{"title":"빅오 표기법 (Big O Notation)","date":"2022-09-18","tags":["TIL","Data Structure","빅오","Big O"],"draft":false,"summary":"빅오 표기법에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n# 1. 빅오 (Big O) 소개\r\n\r\n- `효율성` 체크을 위해 알고리즘 성능을 측정하고 비교한다.\r\n- `input` 값의 증가에 따라 알고리즘의 실행 시간이 어떻게 변하는지에 대해 설명하는 공식적인 방법\r\n- `입력 값의 크기`와 `실행시간의 관계`를 나타낸다.\r\n- `전반적인 추세`에 주목한다.\r\n\r\n# 2. 코드 시간 재기\r\n\r\n- 더 나은 코드의 기준은 뭘까 ? => 속도? 가독성? 메모리 사용량?\r\n- 보통 시간에 집중을 한다. 시간이 중요하지만 단순 시간 측정은 기기의 성능에 차이가 난다.\r\n    그렇다고해서 똑같은 기기에서는 동일하냐? 그것도 아니다.\r\n    똑같은 기기에서도 시간 측정 기록은 차이가 있다.\r\n\r\n- 매번 새로운 방법이 나왔을 때 그것을 측정하는 것도 비용이다\r\n- 그래서 나온것이 빅오이다.\r\n\r\n# 3. 연산 갯수 세기\r\n\r\n- 코드가 실행될 때 걸리는 정확한 시간을 초로 측정하는 것보다는 → 컴퓨터가 처리해야하는 `연산의 갯수`를 세면된다.\r\n- 연산의 정확한 갯수를 세는 것보다는 `전체적인 추세`를 아는 것이 목적이다.\r\n- n값이 커질수록 연산의 갯수도 늘어나는 것은 당연하다. 이렇게 n값에 따른 변화 추이를 그래프로 그렸을 때 해당 알고리즘의 추세를 알 수 있다.\r\n\r\n![시간 복잡도 도식화 @50%](/assets/posts/til/DS&Al/빅오/01.png)\r\n\r\n# 6. 빅오 표현식의 단순화하기\r\n\r\n- 항상 같은 연산 = `O(1)` 실행 시간에 변함이 없다. n이 커져도 같다.\r\n- 선형 관계 (1:1) = `O(n)` n이 커지면 실행시간도 커진다.\r\n\r\n### 실행 시간\r\n1. 산수 = `O(1)`  (+ -  / *)\r\n2. 변수 할당 = `O(1)`\r\n3. 인덱스를 이용해 배열 엘리먼트에 접근 = `O(1)`\r\n4. 키를 통해 오브젝트 엘리먼트에 접근 = `O(1)`\r\n5. 루프 ⇒ 루프 길이에 따라\r\n\r\n```tsx\r\n// 무조건 반목문이 들어간다고 해서 최소 O(n)은 아니다.\r\n// 로직을 어떻게 짜느냐에 따라 다르다.\r\n// 예외\r\n\r\nfunction logAtMost5(n) {\r\n\tfor (let i = 1; i <= Math.min(5, n); i++) {\r\n\t\tconsole.log(i);\r\n\t}\r\n}\r\n\r\nlogAtMost5(1); // 1\r\nlogAtMost5(3); // 1 2 3\r\nlogAtMost5(5); // 1 2 3 4 5\r\nlogAtMost5(10); // 1 2 3 4 5\r\nlogAtMost5(100000); // 1 2 3 4 5\r\n\r\n// 추세를 보면 n값이 커져도 항상 5를 넘지 않는다\r\n// 5미만의 n 값들은 n값의 커짐에 따라 별로 영향을 주지 않는다\r\n// 그렇기에 빅오는 O(1)이다.\r\n```\r\n\r\n# 7. 공간 복잡도\r\n\r\n- 시간 복잡도 → 입력값(n)에 따른 알고리즘의 실행 속도\r\n- 입력값(n)이 커질수록 알고리즘이 얼마나 많은 공간을 차지하는지 고려한다. (메모리 사용량)\r\n- 입력되는 것을 제외하고 알고리즘 자체가 필요로 하는 공간\r\n\r\n1. 원시값들 `(boolean, numbers, undefined, null)`\r\n    - `상수 공간(constant space), O(1)`, 항상 똑같은 공간을 차지 = 불변 공간\r\n2. `String, Reference type, array, object` = `O(n) space`\r\n    - string → 문자의 길이\r\n    - array → 배열의 길이.\r\n    - object → 키의 갯수\r\n- 공간은 입력의 크기에 따른 리턴값 간의 관계\r\n\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"빅오 표기법 (Big O Notation)"},{"data":{"title":"AWS Amplify Next.js 동적 경로(Dynamic Routes) 설정하기","date":"2022-09-17","tags":["TIL","AWS","Amplify","Next.js","Dynamic Routes","동적 경로"],"draft":false,"summary":"Amplify로 배포된 Next.js 프로젝트 동적 경로 설정하기","mainCategory":"platform","subCategory":"AWS"},"content":"\n# 서론\n\n- `static`하게 생성된 `html`파일들을 `Amplify`로 배포할 시에는 `url`에 맞는 `html`파일을 보여준다.\n- 하지만 `동적`으로 설정한 경로 같은 경우 이벤트 리스너로 `Link`이동 시에는 정상 작동하지만, 새로고침하거나 직접 주소창에 `url`을 치고 들어오면 `404 에러`를 반환한다.\n- 그 이유는`static`하게 생성된 `동적 경로`로 만들어진 `html` 파일을 보면 `[id].html` 이런 형식으로 만들어져 있기 때문에 실제 주소창에 적혀있는 `url`에 맞는 `html`파일을 찾지 못하기 때문이다.\n- `Next.js`의 `SSG`를 담당하는 함수를 호출해서 생성하면 각각에 `id`에 맞게 `html`파일을 전부 만들어준다면 `동적 경로`를 따로 설정할 필요가 없다.\n- 허나 실질적으로 `id`가 수백, 수천 개에 달하는 게시물 같은 경우 모든 `html` 파일들을 만들어주는 것은 비효율적이다.\n- 그렇다면 `동적 경로`로 만들어진 `html`파일의 경우 어떤식으로 설정을 하면 될까?\n\n# 사용법\n\n## 1. Amplify 콘솔로 진입 후 설정할 프로젝트로 이동\n- 이후 `다시 쓰기 및 리디렉션`을 클릭한다.\n\n![Amplify 프로젝트 좌측 메뉴](/assets/posts/til/AWS/AWS-Amplify-Next.js-동적-경로(Dynamic-Routes)-설정하기/01.png)\n\n## 2. `다시 쓰기 및 리디렉션` 페이지로 이동\n- 여기서는 라우팅에 관련해서 설정한 목록들을 확인할 수 있다.\n- 이후 `편집`을 누른다.\n\n![다시 쓰기 및 리디렉션 페이지](/assets/posts/til/AWS/AWS-Amplify-Next.js-동적-경로(Dynamic-Routes)-설정하기/02.png)\n\n\n## 3. `다시 쓰기 및 리디렉션` 설정\n- 여기서 오늘 할 `동적 경로`를 설정할 것이다.\n- 이외에도 `200`, `301`, `302`, `404`등 다양한 `status`에 대해 설정이 가능하다.\n\n![다시 쓰기 및 리디렉션 설정 페이지](/assets/posts/til/AWS/AWS-Amplify-Next.js-동적-경로(Dynamic-Routes)-설정하기/03.png)\n\n### 설정법\n\n- `static`하게 생성된 동적 경로로 이루어진 `html`파일 이름을 `대상 주소`에 그리고 파라미터 값의 이름을 그대로 가져다가 `<>`로 바꿔준뒤 `.html`을 제거해서 `소스 주소`에 넣는다.\n- 형식은 `200`으로 설정해준다.\n- `소스 주소`가 실제로 주소창에 표기되는 형식이다.\n> e.g. `/theme/<id>`의 `소스 주소`의 경우 주소창에 표기될 때는 `/theme/primary`, `/theme/secondary`이런 식으로 매칭이 된다.\n\n| 소스 주소 | 대상 주소 | 형식 |\n| ---- | ---- | ----------- |\n| /theme/<id> | /theme/[id].html | 200(다시 쓰기) |\n| /theme/<id>/main.html | /theme/[id]/main.html | 200(다시 쓰기) |\n| /post/<categoryId>/<postId> | /post/[categorId]/[postId].html | 200(다시 쓰기) |\n\n- 위와 같은 형식으로 `다시 쓰기 및 리디렉션` 페이지에서 설정해주면 `동적경로`로 이루어진 페이지로 매칭된다.\n- 이후 `저장`버튼을 누르고 반영 메세지를 확인한 뒤 새로고침이나 직접 주소창에 입력해서 들어가도 정상적으로 `url`에 맞는 `html`을 보여주는 것을 확인할 수 있다.\n\n***\n\n### 참조\n\n- [Using redirects - AWS Amplify Hosting](https://docs.aws.amazon.com/amplify/latest/userguide/redirects.html)\n- [Amplify HostingでのNext.jsのDynamic Routesの設定](https://zenn.dev/nus3/articles/e3da1bdb3ef302962f07)\n\n***\n\n#### 피드백은 언제나 환영입니다.","path":"AWS Amplify Next.js 동적 경로(Dynamic Routes) 설정하기"},{"data":{"title":"[Typescript] tsconfig 절대경로 설정하기","date":"2022-09-15","tags":["TIL","Typescript","tsconfig.json","jsconfig.json","Absolute paths"],"draft":false,"summary":"tsconfig.json 설정을 통해 절대경로를 설정해보자","mainCategory":"tech","subCategory":"typescript"},"content":"\r\n# 서론\r\n- 특정 컴포넌트나 파일을 `import`할 시 경로의 `depth`가 깊어지면 깊어질수록 `import`하려는 파일의 위치에 따라 `상대경로`가 상당히 길어질 수 있다.\r\n```javascript\r\n// 극단적인 예\r\nimport deep from '../../../../../../../A/B/C/file.js';\r\n\r\n// 이런게 수없이 많다면?\r\nimport deep1 from '../../../../../../../A/B/C/file1.js';\r\nimport deep2 from '../../../../../../../A/B/C/file2.js';\r\nimport deep3 from '../../../../../../../A/B/C/file3.js';\r\nimport deep4 from '../../../../../../../A/B/C/file4.js';\r\nimport deep5 from '../../../../../../../A/B/C/file5.js';\r\n...\r\n...\r\nimport deep999 from '../../../../../../../A/B/C/file5.js';\r\n```\r\n- 이런 식으로 상대경로가 길어지면 `import`할 파일을 찾기위한 수고가 커질 뿐더라 가독성 면에서도 좋지 않다.\r\n- `tsconfig.json` or `jsconfig.json`의 설정을 통해 `절대경로`를 설정할 수 있다\r\n\r\n# tsconfig.json 이란?\r\n- `typscript`에 대한 설정을 할 수 있는 파일이며 `javascript`로 이루어진 레포지토리라면 `jsconfig.json`을 사용한다.\r\n- 해당 레포지토리가 `Typescript`를 사용하고 있다면 루트 디렉토리에 `tsconfig.json`이 존재해야며 `tsc`명령어를 통한 컴파일시 로드한다.\r\n- 컴파일러에 대한 옵션 설정과 더불어 다양한 기능을 제공한다.\r\n```json\r\n// tsconfig.json 의 예시\r\n{\r\n  \"compilerOptions\": {\r\n    ...\r\n  },\r\n  \"include\": [...],\r\n  \"exclude\": [...]\r\n}\r\n```\r\n\r\n## 절대경로 설정하기\r\n- `tsconifg.json`에서 `compilerOptions` 옵션의 `baseUrl`과 `paths`를 이용해서 `절대경로`를 설정한다.\r\n- `baseUrl`의 경우 `paths`를 설정하기 위해서는 반드시 설정해야하는 옵션이다.\r\n- `paths`의 경우 `key-value`쌍으로 이루어진 객체이며 절대경로를 정의하고자 하는 경로의 이름을 `key`에 입력하며 `baseUrl`을 기준으로 상대적인 경로를 `value`에 입력한다.\r\n- `paths`의 `key`에는 주로 `@`으로 시작을 하며 바로 다음으로 `/, _` 같은 특수문자를 넣는데 이유는 `@`로 시작하는 패키지가 종종 있기 떄문이다.\r\n```json\r\n// tsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\", // 이 경우는 tsconfig.json이 존재하는 루트 디렉토리를 기준으로 삼는다.\r\n    \"paths\": {\r\n      \"@_components/*\": [\"src/components/*\"],\r\n      \"@_apis/*\": [\"src/api/*\"],\r\n      \"@_types/*\": [\"src/types/*\"],\r\n      \"@_icons/*\": [\"public/assets/icons/*\"],\r\n      \"@_images/*\": [\"public/assets/images/*\"],\r\n      \"@_emojis/*\": [\"public/assets/emoji/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n- 위와 같은 `paths`를 지정한다면 실제로 루트 디렉토리를 기준으로한 구조는 다음과 같다\r\n```text\r\nRoot\r\n├─ public\r\n│   └─ assets\r\n│      ├─ icons\r\n│      ├─ images\r\n│      └─ emojis\r\n└─ src\r\n     ├─ components\r\n     ├─ api\r\n    └─ types\r\n```\r\n- 실제로 적용된 예시를 보자\r\n```typescript\r\nimport path1 from '@_components/home/main.tsx';\r\nimport path2 from '@_icons/sample.png';\r\nimport path2 from '@_apis/member'\r\n```\r\n- 특정 파일뿐만 아니라 모듈도 `절대경로`로 지정이 가능하다.\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n# 추가\r\n\r\n- 절대경로를 추가하는 `paths`가 늘어나면 따로 빼놓는 것도 가능하다.\r\n- `tsconfig.json`의 `extends`옵션을 이용한다.\r\n- 기본 `config` 파일을 읽어온 후 `extends`에 지정한 파일에 의해 오버라이딩(overridden) 된다.\r\n- `include`나 `exclude`에 정의한 파일의 경우 기본 `config` 파일을 덮어쓴다.(overwrite)\r\n- `extends` 옵션은 스트링값으로만 받는다.\r\n- 여러 설정 파일을 `extend`하고 싶다면 줄줄이 이어받는 구조를 만들어야한다.\r\n    ```json\r\n    // tsconfig.a.json\r\n    {\r\n      \"compilerOptions\": {\r\n        ...\r\n      },\r\n    }\r\n    ```\r\n  ```json\r\n  // tsconfig.b.json\r\n  {\r\n    \"compilerOptions\": {\r\n      ...\r\n    },\r\n    \"extends\": \"./tsconfig.a.json\"\r\n  }\r\n    ```\r\n  ```json\r\n  // tsconfig.json\r\n  {\r\n    \"compilerOptions\": {\r\n      ...\r\n    },\r\n    \"extends\": \"./tsconfig.b.json\"\r\n  }\r\n    ```\r\n\r\n## 사용법\r\n- 위에 설정한 파일을 따로 만들어 저장해둔다.\r\n- 파일명은 어떤식으로 지어도 상관없으며, 어느 디렉토리에 속해도 된다. `json`형식이면 된다.\r\n- 아래의 경우 `tsconfig.path.json`을 루트 디렉토리에 만든다.\r\n\r\n```json\r\n// tsconfig.paths.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"@_components/*\": [\"src/components/*\"],\r\n      \"@_apis/*\": [\"src/api/*\"],\r\n      \"@_types/*\": [\"src/types/*\"],\r\n      \"@_icons/*\": [\"public/assets/icons/*\"],\r\n      \"@_images/*\": [\"public/assets/images/*\"],\r\n      \"@_emojis/*\": [\"public/assets/emoji/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n- `tsconfig.json`에 `extends`옵션을 추가한 뒤 확장하고자하는 `json`을 파일을 `tsconifg.json`을 기준으로한` 상대경로`로 입력해준다.\r\n```json\r\n// tsconifg.json\r\n{\r\n  \"compilerOptions\": {\r\n    ...\r\n  },\r\n  \"extends\": \"./tsconfig.paths.json\"\r\n}\r\n```\r\n\r\n\r\n\r\n#\r\n\r\n### 참조\r\n- [TSConfig Reference](https://www.typescriptlang.org/tsconfig)\r\n- [Documentation - What is a tsconfig.json](https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html)\r\n\r\n#\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"[Typescript] tsconfig 절대경로 설정하기"},{"data":{"title":"[Next.js] Page Extensions","date":"2022-09-13","tags":["TIL","Next.js","next.config.js","pageExtensions"],"draft":false,"summary":"next.config.js 파일의 page extensions 옵션을 커스텀해보자","mainCategory":"tech","subCategory":"Next.js"},"content":"\r\n\r\n# 서론\r\n\r\n- 작업을 하다보면 임시적으로 접근을 제한하여야 하는 파일들이 있을 수 있다.\r\n- 폴더 최상위에 존재하는 `next.config.js`의 `pageExtensions`을 통해 `page`디렉토리 내 파일들을 대상으로 확장자명에 따라서 파일의 접근을 막을 수 있다.\r\n- `pageExtensions`의 규칙을 따르지 않은 파일에 대해서는 접근시 `404 (Not Found)`에러를 반환한다.\r\n\r\n#### default pageExtensions\r\n```jsx\r\n// next.config.js\r\nmodule.exports = {\r\n  pageExtensions: ['jsx', 'js', 'tsx', 'ts'],\r\n}\r\n```\r\n\r\n\r\n# 사용법\r\n> e.g. `page.` prefix를 붙일 시\r\n```jsx\r\nmodule.exports = {\r\n  pageExtensions: ['page.tsx', 'page.ts', 'page.jsx', 'page.js'],\r\n}\r\n```\r\n- 위와 같이 확장자명을 설정한다면 `pages` 디렉토리 내에 포함하고자 하는 파일의 확장자명에 전부 `page.`을 붙여야한다.\r\n- `_document`, `_app` 그리고 `pages/api`내에 있는 파일에도 동일하게 적용시켜 주어야한다.\r\n\r\n## 현재 디렉토리 구조\r\n```text\r\n└─ pages\r\n    ├─ _app.page.tsx\r\n    ├─ _document.page.tsx\r\n    ├─ home\r\n    │  └─ main.page.tsx\r\n    │  └─ exclude.tsx  // 제외\r\n    └─ main.page.tsx\r\n```\r\n#\r\n### 빌드시\r\n```text\r\nPage\r\n┌ ● /\r\n├   /_app\r\n├ ○ /404\r\n└ ● /home/main\r\n```\r\n#\r\n### `exclude.page.tsx`로 확장자명 변경후 재빌드시\r\n```text\r\nPage\r\n┌ ● /\r\n├   /_app\r\n├ ○ /404\r\n├ ● /home/exclude\r\n└ ● /home/main\r\n```\r\n\r\n\r\n#\r\n\r\n### 참고\r\n- [Custom Page Extensions](https://nextjs.org/docs/api-reference/next.config.js/custom-page-extensions#including-non-page-files-in-the-pages-directory)\r\n\r\n#\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"[Next.js] Page Extensions"}]},"__N_SSG":true}