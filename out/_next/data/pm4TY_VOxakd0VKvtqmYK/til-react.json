{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":1}]},{"title":"tech","sub":[{"title":"refactoring","count":3},{"title":"typescript","count":1}]},{"title":"til","sub":[{"title":"AWS","count":1},{"title":"CS","count":1},{"title":"CSS","count":1},{"title":"Google Analytics 4","count":1},{"title":"javascript","count":2},{"title":"markdown","count":1},{"title":"programming","count":2},{"title":"react","count":2}]}],"data":[{"data":{"title":"setState 파헤치기","date":"2022-08-24","tags":["TIL","React","Hook","setState"],"draft":false,"summary":"useState의 setState"},"content":"# 서론\n\n- `React`를 사용하게 되면 `state`를 업데이트 해야하는 상황이 온다.\n- `state`를 업데이트할 때 사용하는 `useState`의 `setState`에 대해 알아보자.\n- `setState`를 사용할때 함수를 넣는 경우와 값을 직접 넣는 경우를 본 적이 있을 것이다.\n- 각각의 경우가 어떠한 방식으로 실행되고 차이점은 무엇일까?\n- `setState`가 무엇인지 그리고 어떠한 방식으로 실행되는지 알아보자\n\n# 1. setState\n\n- `React`를 쓰면서 가장 많이 쓰는 메소드이다.\n- `useState` 훅에서 호출하는 메소드 이다.\n- `state`의 업데이트를 위해 사용된다.\n- `state`를 업데이트하면 `리랜더링`이 일어난다.\n- `비동기적`으로 동작한다.\n\n# 2. 사용법\n\n## 1.  updater 함수를 이용한 방식\n\n### 형태\n\n```jsx\nconst [state, setState] = useState(0)\n\nsetState((prev) => prev +1);\n```\n\n## 2. state 값을 이용한 방식\n\n### 형태\n\n```jsx\nconst [state, setState] = useState(0)\n\nsetState(state + 1)\n```\n\n# 3. 차이점\n\n- 가장 큰 차이점은 `state`변경 시 이전 값의 보장 유무이다.\n- 이게 무슨 말이냐? 예제를 보자\n\n- 위와 똑같이 `state`를 1씩 증가시키는 함수가 있다고 가정하자\n- `setState`는 똑같이 1씩 증가시킨다. 그렇다면 `setState`를 두번 실행시키는 `increase1`, `increase2`에서 값이 동일하게 2씩 늘어날까?\n\n```jsx\nconst [state, setState] = useState(0)\n\nconst increase1 = () => {\n    setState((prev) => prev +1);\n    setState((prev) => prev +1);\n};\n// result +2 per click\n\nconst increase2 = () => {\n    setState(state + 1);\n    setState(state + 1);\n};\n// result +1 per click\n```\n\n## 결과\n\n- `increase1` = +2 증가하고, `increase2` = +1 증가한다.\n\n### WHY?\n\n- 바로 `setState`는 `비동기적`으로 동작하기 때문이다.\n- `setState`는 호출 즉시 동작하지 않는다.\n- `React`에서는 효율적으로 처리하기 위해서 `state`를 변경하겠다고 대기열에 추가한 뒤, 여러 변경 사항들과 `묶어서 한번에 업데이트` 한다.\n- 그렇기 때문에 `increase2`의 경우 `setState`를 2번 호출하지만 한꺼번에 묶어서 처리하기 때문에 +1씩 증가하는 것이다.\n- 함수를 이용한 방식은 `setState`가 `state`를 변경하는 시점에 이전 값을 참조하기 때문에 +2씩 증가한다.\n\n#\n\n### 참조\n- [React 공식문서](https://ko.reactjs.org/docs/react-component.html#setstate)\n\n#\n\n### 피드백은 언제나 환영입니다.","path":"setState 파헤치기"},{"data":{"title":"이미지를 어디에 저장할까","date":"2022-08-31","tags":["TIL","React","Image and Icon","src","public"],"draft":false,"summary":"이미지와 같은 에셋들은 어디에 저장할까? src vs public"},"content":"# 서론\n\n- `React`나 `Next.js`를 사용하다 보면 `이미지`를 어디에 저장해야할지 고민할 때가 있다.\n- 크게 이미지를 사용하는 방식은 3가지가 있다.\n\n# 1. `public` 폴더에 저장하여 사용\n\n- 첫번째 방법은 `public` 폴더에 저장하여 사용하는 방법이다.\n- `public`에 있는 파일들은 정적 파일이며 동적으로 불러와 사용하기 쉽다.\n- 빌드 시 영향이 가지 않는 폴더이며 `webpack`으로 처리되지 않고 `빌드된 폴더`에 `그대로` 저장된다.\n- `Next.js`의 경우, 사용자가 요청할 때 자체적으로 제공해주는 `next/image`컴포넌트를 통해 `이미지를 최적화`해준다. 그렇기에 빌드 시에 허비되는 시간이 없으며, `src`에 저장하지 않아도 된다.\n\n\n# 2. `src` 폴더에 저장하여 사용\n\n- 두번째 방법은 `src` 폴더에 저장하여 사용하는 방법이다.\n- `React`와 같은 자체적으로 최적화할 수 있는 방법이 없는 경우에서는 주로 이 방법을 사용한다.\n- 해당 이미지를 쓰는 컴포넌트 폴더에 같이 저장해 별도로 이미지를 관리하거나, `assets`에서 관리하는 등 구조는 다양하다.\n- `webpack`에서 처리되기 때문에 추가적인 최적화가 가능하다.\n\n\n# 3. 외부 서버 이미지 사용\n\n- 세번째 방법은 `AWS S3`와 같은 외부 스토어에 저장 후 불러와 쓰는 방법이다.\n- 따로 이미지에 대한 관리에 신경 쓰지 않아도 된다.\n- 이미지가 바뀌어도 브라우저 캐시 때문에 바뀌기 이전에 이미지가 불러와진다. 그렇기 때문에 이미지가 바뀔 시에 `content hash`과 같은 특정한 값들을 부여해서 저장하거나 받아올 때 다르게 받아와야한다. 아니면 캐싱시간을 짧게 가지는 것 또한 방법이다.\n\n#\n\n### 참고\n- 각각의 이미지를 사용하는 방법은 따로 포스팅으로 다룰 예정이다.\n\n### 참조\n- [Where to Store Images in React App](https://www.upbeatcode.com/react/where-to-store-images-in-react-app/)\n- [Image Component and Image Optimization](https://nextjs.org/docs/basic-features/image-optimization#local-images)\n\n#\n\n### 피드백은 언제나 환영입니다.","path":"이미지를 어디에 저장할까"}]},"__N_SSG":true}