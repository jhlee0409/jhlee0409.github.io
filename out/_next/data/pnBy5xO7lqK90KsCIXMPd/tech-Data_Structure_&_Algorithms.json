{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":1},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":[{"data":{"title":"빅오 표기법 (Big O Notation)","date":"2022-09-18","tags":["TIL","Data Structure","빅오","Big O"],"draft":false,"summary":"빅오 표기법에 대해 알아보자","mainCategory":"tech","subCategory":"Data_Structure_&_Algorithms"},"content":"\r\n# 1. 빅오 (Big O) 소개\r\n\r\n- `효율성` 체크을 위해 알고리즘 성능을 측정하고 비교한다.\r\n- `input` 값의 증가에 따라 알고리즘의 실행 시간이 어떻게 변하는지에 대해 설명하는 공식적인 방법\r\n- `입력 값의 크기`와 `실행시간의 관계`를 나타낸다.\r\n- `전반적인 추세`에 주목한다.\r\n\r\n# 2. 코드 시간 재기\r\n\r\n- 더 나은 코드의 기준은 뭘까 ? => 속도? 가독성? 메모리 사용량?\r\n- 보통 시간에 집중을 한다. 시간이 중요하지만 단순 시간 측정은 기기의 성능에 차이가 난다.\r\n    그렇다고해서 똑같은 기기에서는 동일하냐? 그것도 아니다.\r\n    똑같은 기기에서도 시간 측정 기록은 차이가 있다.\r\n\r\n- 매번 새로운 방법이 나왔을 때 그것을 측정하는 것도 비용이다\r\n- 그래서 나온것이 빅오이다.\r\n\r\n# 3. 연산 갯수 세기\r\n\r\n- 코드가 실행될 때 걸리는 정확한 시간을 초로 측정하는 것보다는 → 컴퓨터가 처리해야하는 `연산의 갯수`를 세면된다.\r\n- 연산의 정확한 갯수를 세는 것보다는 `전체적인 추세`를 아는 것이 목적이다.\r\n- n값이 커질수록 연산의 갯수도 늘어나는 것은 당연하다. 이렇게 n값에 따른 변화 추이를 그래프로 그렸을 때 해당 알고리즘의 추세를 알 수 있다.\r\n\r\n![시간 복잡도 도식화 @50%](/assets/posts/til/DS&Al/빅오/01.png)\r\n\r\n# 6. 빅오 표현식의 단순화하기\r\n\r\n- 항상 같은 연산 = `O(1)` 실행 시간에 변함이 없다. n이 커져도 같다.\r\n- 선형 관계 (1:1) = `O(n)` n이 커지면 실행시간도 커진다.\r\n\r\n### 실행 시간\r\n1. 산수 = `O(1)`  (+ -  / *)\r\n2. 변수 할당 = `O(1)`\r\n3. 인덱스를 이용해 배열 엘리먼트에 접근 = `O(1)`\r\n4. 키를 통해 오브젝트 엘리먼트에 접근 = `O(1)`\r\n5. 루프 ⇒ 루프 길이에 따라\r\n\r\n```tsx\r\n// 무조건 반목문이 들어간다고 해서 최소 O(n)은 아니다.\r\n// 로직을 어떻게 짜느냐에 따라 다르다.\r\n// 예외\r\n\r\nfunction logAtMost5(n) {\r\n\tfor (let i = 1; i <= Math.min(5, n); i++) {\r\n\t\tconsole.log(i);\r\n\t}\r\n}\r\n\r\nlogAtMost5(1); // 1\r\nlogAtMost5(3); // 1 2 3\r\nlogAtMost5(5); // 1 2 3 4 5\r\nlogAtMost5(10); // 1 2 3 4 5\r\nlogAtMost5(100000); // 1 2 3 4 5\r\n\r\n// 추세를 보면 n값이 커져도 항상 5를 넘지 않는다\r\n// 5미만의 n 값들은 n값의 커짐에 따라 별로 영향을 주지 않는다\r\n// 그렇기에 빅오는 O(1)이다.\r\n```\r\n\r\n# 7. 공간 복잡도\r\n\r\n- 시간 복잡도 → 입력값(n)에 따른 알고리즘의 실행 속도\r\n- 입력값(n)이 커질수록 알고리즘이 얼마나 많은 공간을 차지하는지 고려한다. (메모리 사용량)\r\n- 입력되는 것을 제외하고 알고리즘 자체가 필요로 하는 공간\r\n\r\n1. 원시값들 `(boolean, numbers, undefined, null)`\r\n    - `상수 공간(constant space), O(1)`, 항상 똑같은 공간을 차지 = 불변 공간\r\n2. `String, Reference type, array, object` = `O(n) space`\r\n    - string → 문자의 길이\r\n    - array → 배열의 길이.\r\n    - object → 키의 갯수\r\n- 공간은 입력의 크기에 따른 리턴값 간의 관계\r\n\r\n\r\n#### 피드백은 언제나 환영입니다.","path":"빅오 표기법 (Big O Notation)"}]},"__N_SSG":true}