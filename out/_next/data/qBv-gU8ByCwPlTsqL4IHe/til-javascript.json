{"pageProps":{"categories":[{"title":"tech","sub":[{"title":"refactoring","count":3},{"title":"styled_components","count":1},{"title":"typescript","count":1}]},{"title":"til","sub":[{"title":"javascript","count":1}]}],"data":[{"data":{"title":"import 파헤치기","date":"2022-08-16","tags":["TIL","Javascript"],"draft":false,"summary":"static import, dynamic import"},"content":"# import\n\n- `import` 할 모듈은 무조건 `엄격 모드`\n- HTML 안에 작성한 스크립트에는 `import` 사용 불가\n\t- 대신 `<script>` 태그의 `nomodule`속성을 이용해 가능\n- 정적 `import` 는 다른 모듈에서 `export` 한 바인딩을 가져올 떄 사용\n\t- 초기 의존성을 불러올 때 사용\n\t- 가져올 모듈은 `문자열` 만 허용\n- 동적 `import` 는 함수형 구문인 `import()` 를 사용\n\t- `type=\"module\"` 을 필요로 하지 않는다.\n\t- 모듈을 조건적으로 가져오고 싶을 때 사용\n\t- 필요할 때만 가져올 떄 사용\n\n\n## 정적 import\n### 사용법\n1. 기본값 가져오기\n\t- `module` 파일에서 `export default` 한 값 가져오기\n\t```javascript\n\timport a from 'module';\n\t```\n2. Name Space Import\n\t- 전체 모듈 가져오기\n\t```javascript\n\timport * as aliasA from 'module';\n\t```\n3. 하나의 멤버만 가져오기\n\t```javascript\n\timport { memberA } from 'module';\n\t```\n4. 여러 멤버 가져오기\n\t```javascript\n\timport { memberA, memberB } from 'module';\n\t```\n5. 별명 지정해서 멤버 가져오기\n\t```javascript\n\timport {realMemberName as aliasMemberName} from 'module';\n\timport {realMemberNameA as aliasMemberNameA, realMemberNameB as \n\taliasMemberNameB} from 'module';\n\t```\n6. 바인딩없이 모듈 전체의 사이드 이펙트 가져오기\n\t```javascript\n\timport 'module';\n\t```\n7. 기본값 가져오기 + 멤버 가져오기\n\t- 기본값 가져오기 먼저 선언 해야함\n\t```javascript\n\timport sampleDefault, * as aliasA from 'module';\n\t// or\n\timport sampleDefault, { memberA, memberB } from 'module';\n\t```\n\n## 동적 import\n- 제약이 존재\n\t1. `import` 문에 동적 매개변수 사용 불가\n\t\t```javascript\n\t\timport impossible from getModuleA(); \n\t\t```\n\t2. 모듈 경로는 원시 문자열만 가능, 함수 호출 결괏값을 경로로 사용 불가\n\t3. 런타임 or 조건부로 모듈을 불러올 수 없다는 점\n\t```javascript\n\tif(...conditionA) {\n\t\timport ...; // 조건부 호출 불가\n\t}\n\t// or\n\t{\n\t\timport ...; // 블록 안에서 호출 불가\n\t}\n\t```\n### 왜 제약이 있지?\n- `import/export`는 코드 쿠조의 중심을 잡아주는 역할이기 때문\n- 코드 구조 분석 -> 모듈을 모아 번들링 -> 미사용 모듈은 제거 하는 프로세스\n- 코드 구조가 간단 & 고정일 경우에만 가능\n\n### 사용법\n- `import(module)` -> 프로미스를 반환\n- 코드 내 어디서 동적으로 호출, 사용 가능\n```javascript\nimport('module path')\n\t.then(obj=>`obj === module object`)\n\t.catch(err => `loading err, e.g. no matched module`)\n```\n- 비동기 함수에서도 가능\n```javascript\nconst myFunction = async () => {\n\tconst module = await import('modulepath')\n\t...\n}\n```\n\n### 주의 \n- 일반 스크립트에서도 동작 `<script type=\"module\" >` 불필요\n- 함수 호출 처럼 보이지만 함수 호출 아님\n- `super()` 처럼 괄호를 쓰는 특별한 문법\n- 그렇기에 `import`를 변수에 복사, 함수의 메소드인  `call/apply` 사용 불가","path":"import 파헤치기"}]},"__N_SSG":true}