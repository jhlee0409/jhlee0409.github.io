{"pageProps":{"categories":[{"title":"blockchain","sub":[{"title":"DApp","count":1},{"title":"solidity","count":4}]},{"title":"platform","sub":[{"title":"AWS","count":2},{"title":"Google Analytics 4","count":1}]},{"title":"tech","sub":[{"title":"CS","count":1},{"title":"CSS","count":2},{"title":"Data_Structure_&_Algorithms","count":12},{"title":"HTML","count":1},{"title":"javascript","count":4},{"title":"markdown","count":1},{"title":"Next.js","count":1},{"title":"programming","count":3},{"title":"react","count":2},{"title":"refactoring","count":3},{"title":"typescript","count":2}]}],"data":{"title":"빅오로 보는 배열과 객체의 성능 평가","date":"2022-09-22","tags":["TIL","Udemy","Data Structure","빅오","Big O","Object","Array"],"draft":false,"summary":"배열과 객체 그리고 내장된 메소드들의 성능은?"},"content":"\r\n# 1. 객체(Object)의 빅오(Big O)\r\n\r\n- 객체는 정렬되어 있지 않다.\r\n- 저장, 접근, 제거, 수정의 경우 `O(1)`이 걸린다.\r\n- 탐색은 단순하게 `key`에 접근하는 것이 아닌 `value`를 가져와야하기에 `O(n)`이 걸린다.\r\n\r\n    ```js\r\n     const obj = { name: \"jack\", age: 0 };\r\n    // 'jack' 이라는 값이 어디에 저장되어 있는가를 알기위해서는 모든 `key`값을 돌며 `value`를 체크해야한다.\r\n    ```\r\n\r\n- `Object.keys, Object.values, Object.entries` 메소드들의 경우 `O(n)`이 걸린다.\r\n    - 객체를 돌며 다 배열에 담아 반환해야하기 떄문이다.\r\n- `hasOwnProperty`의 경우 `O(1)`이 걸린다.\r\n    - `key`가 있는지 없는지 바로 접근이 가능하기 때문이다.\r\n\r\n&nbsp;\r\n\r\n# 2. 배열(Array)의 빅오(Big O)\r\n\r\n- 배열은 정렬된 데이터이다. 그렇기에 각 값에 인덱스가 붙어있다.\r\n\r\n- 접근의 경우 `O(1)`이 걸린다.\r\n    - `index`로 바로 접근하면 되기 때문이다.\r\n\r\n- 탐색은 객체와 동일하게 `O(n)`이 걸린다.\r\n\r\n- 저장의 경우 어디에 저장하느냐에 따라 빅오가 달라진다.\r\n    - `push`메소드는 배열의 끝에 저장하기 때문에 `O(1)`이 걸린다.\r\n    - `unshift`메소드는 배열의 처음에 저장하기 때문에 `O(n)`이 걸린다.\r\n\r\n- 제거의 경우도 어디를 제거하느냐에 따라 빅오가 달라진다.\r\n  - `pop` 메소드는 배열의 끝값을 제거하기 때문에 `O(1)`이 걸린다.\r\n  - `shift`메소드는 배열의 처음값을 제거하기 때문에 `O(n)`이 걸린다.\r\n\r\n&nbsp;\r\n\r\n## 왜? 같은 저장, 제거인데 다르죠?\r\n\r\n- 인덱스 번호의 재배치 때문이다.\r\n- 배열의 끝에 `저장/제거`하는 경우는 끝에 값이 있기 때문에 다른 값들의 인덱스는 변화가 없다.\r\n- 하지만 배열의 처음에 `저장/제거`하는 경우는 그 작업을 수행한 후 나머지 값들의 인덱스를 재배치 해주어야하기 때문이다.\r\n\r\n    ```js\r\n    // 기존의 0번 인덱스에 위치한 값은 \"A\"이지만 shift 호출이후 \"B\"로 바뀌게 된다.\r\n    // 즉, 0번 인덱스의 값이 제거가 되면 나머지 값들의 인덱스 번호가 하나씩 떙겨져 재배치 된다.\r\n    const arr = [\"A\", \"B\", \"C\", \"D\"];\r\n    arr[0] // \"A\"\r\n    arr.shift()\r\n    arr[0] // \"B\"\r\n    ```\r\n\r\n- 비어있는 배열의 경우를 제외하고 `push, pop`메소드는 `shift, unshift`보다 빠르다.\r\n- `push, pop`메소드의 경우`O(1)`이 걸린다.\r\n- `shift, unshift, concat, slice, splice`메소드의 경우 `O(n)`이 걸린다.\r\n- `sort`메소드의 경우 `O(n* log n)`이 걸린다. (추후 포스팅)\r\n- `forEach, map, filter, reduce`메소드의 경우 `O(n)`이 걸린다.\r\n\r\n\r\n---\r\n\r\n\r\n#### 피드백은 언제나 환영입니다."},"__N_SSG":true}