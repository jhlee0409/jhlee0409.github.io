---
title: "Helper 메소드 재귀 패턴"
date: "2022-10-02"
tags: ["TIL", "Udemy", "Algorithm", "헬퍼 메소드", 'Helper Method']
draft: false
summary: "헬퍼 메소드 재귀 패턴을 이용해서 직관적인 재귀 함수를 구현해보자"
---

&nbsp;

# Helper 메소드 재귀 패턴

- 재귀 함수를 실행했을 때 특정 값들을 담은 `배열`을 반환해야하는 경우, 순수 재귀 함수만으로는 까다롭다. 이유는 재귀 함수를 호출 할떄마다
재귀 함수 내의 변수는 초기값으로 리셋되기 마련인데, 이 변수의 값들을 재귀를 돌때마다 이전 값을 유지하면서 반환하는 작업을 따로 구현해주어야 하기 떄문이다.
그렇기 때문에 재귀 함수를 감싸는 함수를 하나 만들어서 그곳에 결과 변수를 하나 두고 재귀 함수를 통해 얻은 특정 값을 담는다.
- Helper 메소드 재귀를 쓰는 것이 더 직관적이다.

&nbsp;

## Helper 메소드 재귀 패턴으로 구현했을 때

- 어떤 결과를 컴파일하 때 흔히 사용되는 패턴이다.
- 재귀 함수를 감싸는 재귀로 구현되지 않은 함수를 사용하는 패턴이다.
- `collectOddValues()` : 재귀로 구현되지 않은 함수
- `helper()` : 재귀 함수
- `result`를 `helper`함수 안에 정의하게 되면 함수가 호출될 떄마다 빈배열로 리셋되기 때문에 때문에 밖으로 뺸다.

```jsx
const collectOddValues = (arr) => {
    let result = [];
    const helper = (helperInput) => {
        if (helperInput.length === 0) {
            return;
        }
        if (helperInput[0] % 2 !== 0) {
            result.push(helperInput[0]);
        }
        helper(helperInput.slice(1));
    };
    helper(arr);
    return result;
};

collectOddValues([1, 2, 3, 4]);
```

&nbsp;

## 순수 재귀 함수로 구현했을 때

```jsx
const collectOddValues = (arr) => {
    let newArr = [];

    if(arr.length === 0) {
        return newArr;
    }

    if(arr[0] % 2 !== 0) {
        newArr.push(arr[0]);
    }

    newArr = newArr.concat(collectionOddvalues(arr.slice(1)));

    return newArr;
};

// 순수 재귀 함수의 콜 스택 과정
collectOddValues([1, 2, 3, 4, 5]); // => [1, 3, 5]
    [1].concat(collectOddValues([2,3,4,5])) // => [3, 5]
                    [ ].concat(collectOddValues([3,4,5])) // => [3, 5]
                                    [3].concat(collectOddValues([4,5])) // => [5]
                                                    [ ].concat(collectOddValues([5])) // => [5]
                                                                    [5].concat(collectOddValues([ ])) // => []
                                                                                    [ ]
```

&nbsp;

## Helper 메소드 없이 순수 재귀 함수를 구현했을 때 사용하는 유용한 메소드

- 배열을 사용하는 경우
    - 배열을 복사하는 `slice, spread 연산자, concat` 같은 메소드를 사용할 수 있다. 그러면 배열을 변경할 필요가 없다.
- 문자열을 사용하는 경우
    - 문자열은 불변하기(변경할 수 없기) 때문에 `slice, substr, substring` 메소드들을 이용해서 문자열의 복사본을 만든다.
- 객체를 사용하는 경우
    - 객체의 경우 `Object.assign, spread 연산자`를 이용해서 복사본을 만들어 구현한다.
---

#### 피드백은 언제나 환영입니다.