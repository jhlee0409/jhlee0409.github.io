---
title: "다중 포인터 패턴 (Multiple Pointers Pattern)"
date: "2022-09-24"
tags: ["TIL", "Udemy", "Algorithm", "다중 포인터 패턴", 'Multiple Pointers Pattern']
draft: false
summary: "여러 문제해결 패턴 중 다중 포인터 패턴에 대해 알아보자"
---

&nbsp;

# 1. 다중 포인터 패턴 (Multiple Pointers Pattern)

- 인덱스나 위치에 해당하는 `포인터나 값`을 만든 다음 특정 조건에 따라 중간 지점에서부터 `시작 지점`이나 `끝 지점`이나 `양쪽 지점`을 향해 이동시킨다.
- 두 개의 포인터를 지정하고 포인터의 위치를 변경하면서 `특정 조건에 맞는 쌍 or 값`을 찾는 것

&nbsp;

> e.g. 정렬된 배열을 취하는 `sumZero` 라는 함수 작성.
오름차순으로 정렬되어 있어야 한다.
처음으로 합해서 0이 되는 쌍을  찾으면 된다.


## 일반적인 패턴
- 시간 복잡도 : `O(n^2)`
- 공간 복잡도 : `O(1)`
- `for문`이중 반복문을 사용한다.

```js
const sumZero = (arr) => {
    for(const i in arr) {
        for (const j in arr) {
        // 합이 0이면 해당 값들 리턴
        // 나올 때까지 돈다... 돌다가 나오면 리턴 아니면 끝까지 쭉 하고 undefined
         if(arr[i] + arr[j] === 0) {
             return [arr[i], arr[j]]
         }
        }
    }
};
sumZero([-4, -3, -2, -1, 0 , 1, 2, 5]) // [-2, 2]
```

## 빈도  카운터 패턴

- 시간 복잡도 : `O(n)`
- 공간 복잡도 : `O(1)`
- 양 끝에 인덱스를 포인터로 지정하고 합이 0에 맞는 값을 찾아나가는 과정이다.
- 합이 0이 안된다면 좌, 우의 포인터를 한 칸씩 번갈아서 가운데 방향을 이동시키면서 합이 0이되는 인덱스의 값을 찾아낸다.

```js
const sumZero = (arr) => {
    let left = 0; // 배열의 첫번째 인덱스 지정
    let right = arr.length - 1; // 배열의 끝 지점에 인덱스 지정

    while(left < right) {
      const sumNumber = arr[left] + arr[right];
        // 합이 0이면 해당 값들 리턴
        if(sumNumber === 0) {
            return [arr[left], arr[right]]
        // 합이 0보다 크면 우측 포지션 -1
        } else if (arr[left] + arr[right] > 0) {
            right--;
        //합이 0보다 작거나 같으면 좌측 포지션 + 1
        } else {
            left++;
        }
    }
};

sumZero([-4, -3, -2, -1, 0 , 1, 2, 5])
```

---

#### 피드백은 언제나 환영입니다.