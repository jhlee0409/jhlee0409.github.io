---
title: "버블 정렬 (Bubble Sort)"
date: "2022-10-13"
tags: ["TIL", "Udemy", "Algorithm", "버블 정렬", 'Bubble Sort Algorithm']
draft: false
summary: "버블 정렬에 대해 알아보자"
---

&nbsp;

# 버블 정렬(Bubble Sort)

- `버블 정렬`은 숫자로된 배열을 오름차순으로 정렬을 한다면 더 큰 순자가 한 번에 하나씩 뒤로 이동을 한다는 것이다.
- `버블 정렬`은 별로 효율적이지도 않고 잘 사용하지 않는다.
- `싱킹 정렬(Sinking Sort)`라고도 한다.
- 반복을 한번 돌 때마다 가장 큰 숫자는 우측에 정렬되기 때문에 반복을 거듭할 때마다 정렬해야하는 항목의 수는 감소되게 로직을 짜는 것이 효율적이다.
- [VisuAlgo - Sorting](https://visualgo.net/en/sorting)는 여러 정렬 알고리즘의 루프 프로세스를 잘 보여준다.

&nbsp;

- 중첩 루프 내의 `swap`을 이용해서 정렬한다.

```javascript
// ES5
function swap(arr, idx1, idx2) {
	var temp = arr[idx1];
	arr[idx1] = arr[idx2];
	arr[idx2] = temp;
}

// ES2015
const swap = (arr, idx1, idx2) => {
	[arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}
```

# 버블 정렬의 의사코드

- `i` 라는 변수를 갖고 배열의 맨 끝에서 루프를 시작해서 맨 앞에서 끝난다.
    - why? 배열의 항목 수를 줄이기 위해
- 외부 반복문 안에는 `j` 라는 변수가 포함된 내부 루프가 있고 내부 루프틑 처음부터 `i - 1` 까지 실행된다,
- `i` 는 첫 번째 루프를 참조한다. 첫 번째 루프에 의존하는 중첩 루프이다.
- `arr[j]` 이 `arr[j+1]` 보다 크다면 두 값을 바꾼다.
- 정렬된 배열을 반환한다.

## 버블 정렬 구현

- 최적화 작업이 안된 버블 정렬은  맨 앞에서 시작해서 맨 끝에서 종료되는 중첩 루프 2개 사용한다.
```javascript
// 방안1
const bubbleSort = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length; j++) {
      console.log(arr, arr[j], arr[j + 1]);
      if (arr[j] > arr[j + 1]) {
        // swap
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
    console.log("정렬 한번 끝");
  }
  return arr;
};


// 방안2
const bubbleSort = (arr) => {
  const swap = (arr, idx1, idx2) => {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  };
  for (let i = arr.length; i > 0; i--) {
    for (let j = 0; j < i - 1; j++) {
      console.log(arr, arr[j], arr[j + 1]);
      if (arr[j] > arr[j + 1]) {
        // swap
        swap(arr, j, j + 1);
      }
    }
    console.log("정렬 한번 끝");
  }
  return arr;
};

bubbleSort([56,42,12,20]);

// 이미 정렬된 항목은 정렬할 필요가 없음에도 불구하고 루프는 계속 돈다. 그리고 배열의 인덱스를 넘어 비교하는 작업도 한다.
[56, 42, 12, 20] 56 42
[42, 56, 12, 20] 56 12
[42, 12, 56, 20] 56 20
[42, 12, 20, 56] 56 undefined
정렬 한번 끝
[42, 12, 20, 56] 42 12
[12, 42, 20, 56] 42 20
[12, 20, 42, 56] 42 56
[12, 20, 42, 56] 56 undefined
정렬 한번 끝
[12, 20, 42, 56] 12 20
[12, 20, 42, 56] 20 42
[12, 20, 42, 56] 42 56
[12, 20, 42, 56] 56 undefined
정렬 한번 끝
[12, 20, 42, 56] 12 20
[12, 20, 42, 56] 20 42
[12, 20, 42, 56] 42 56
[12, 20, 42, 56] 56 undefined

// result
[12, 20, 42, 56]
```

&nbsp;

- 끝 배열부터 시작하는 이유는 루프를 진행할 수록 비교 횟수를 줄이기 위해서이다.

```javascript
const bubbleSort = (arr) => {
  for (let i = arr.length; i > 0; i--) {
    for (let j = 0; j < i - 1; j++) {
      console.log(arr, arr[j], arr[j + 1]);
      if (arr[j] > arr[j + 1]) {
        // swap
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
    console.log("정렬 한번 끝");
  }
  return arr;
};

bubbleSort([56,42,12,20]);

// j < i - 1 로 인해서 루프를 거듭할수록 i이 하나씩 줄어들며 이중 루프가 도는 횟수도 하나씩 줄어든다.
[56, 42, 12, 20] 56 42
[42, 56, 12, 20] 56 12
[42, 12, 56, 20] 56 20
정렬 한번 끝
[42, 12, 20, 56] 42 12
[12, 42, 20, 56] 42 20
정렬 한번 끝
[12, 20, 42, 56] 12 20
정렬 한번 끝

//result
[12, 20, 42, 56]
```

&nbsp;

## 최적화

- 거의 정렬된 상태에서는 어떻게 하는게 좋을까
- 기본적인 버블 정렬은 똑같이 하나하나 비교하며 처리한다.
- 배열의 루프 횟수를 하나씩 줄여나가기에 정렬이 어느정도 되어있든 없든 루프는 횟수만큼 돈다.

### 해결

- 교환 유무를 판별하는 변수를 하나둔다.
- 교환이 일어났다면 정렬 중인 것이고 그렇지 않다면 이미 정렬되어 있는 상태이다.
- 그렇기에 교환이 안되어있다고 판별되면 루프를 빠져나온다.

&nbsp;

#### 최적화 작업 전

```text
// 28번
1. [8, 1, 2, 3, 4, 5, 6, 7] 8 1
2. [1, 8, 2, 3, 4, 5, 6, 7] 8 2
3. [1, 2, 8, 3, 4, 5, 6, 7] 8 3
4. [1, 2, 3, 8, 4, 5, 6, 7] 8 4
5. [1, 2, 3, 4, 8, 5, 6, 7] 8 5
6. [1, 2, 3, 4, 5, 8, 6, 7] 8 6
7. [1, 2, 3, 4, 5, 6, 8, 7] 8 7
 정렬 한번 끝 // ============ 이 시점에서 이미 정렬이 끝났지만 루프는 계속돈다.
8.[1, 2, 3, 4, 5, 6, 7, 8] 1 2
...
26. [1, 2, 3, 4, 5, 6, 7, 8] 1 2
27. [1, 2, 3, 4, 5, 6, 7, 8] 2 3
정렬 한번 끝
28. [1, 2, 3, 4, 5, 6, 7, 8] 1 2

// result
[1, 2, 3, 4, 5, 6, 7, 8]
```

&nbsp;

#### 최적화 작업 후
- `noSwaps` 변수를 하나 두고 교환 여부에 따라 값을 바꾼다.
```javascript
const bubbleSort = (arr) => {
  let noSwaps; // =============== 변수 선언
  const swap = (arr, idx1, idx2) => {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  };
  for (let i = arr.length; i > 0; i--) {
    noSwaps = true; // =============== 기본적으로 교환을 안한다고 가정
    for (let j = 0; j < i - 1; j++) {
      console.log(arr, arr[j], arr[j + 1]);
      if (arr[j] > arr[j + 1]) {
        // swap
        swap(arr, j, j + 1);
        noSwaps = false; // =============== 교환을 한다면 false
      }
    }
    console.log("정렬 한번 끝");
    if (noSwaps) break; // =============== 교환을 하지 않았다면 루프 탈출
  }
  return arr;
};

bubbleSort([8,1,2,3,4,5,6,7]);
```


```text
// 13번
1. [8, 1, 2, 3, 4, 5, 6, 7] 8 1
2. [1, 8, 2, 3, 4, 5, 6, 7] 8 2
3. [1, 2, 8, 3, 4, 5, 6, 7] 8 3
4. [1, 2, 3, 8, 4, 5, 6, 7] 8 4
5. [1, 2, 3, 4, 8, 5, 6, 7] 8 5
6. [1, 2, 3, 4, 5, 8, 6, 7] 8 6
7. [1, 2, 3, 4, 5, 6, 8, 7] 8 7
정렬 한번 끝
8. [1, 2, 3, 4, 5, 6, 7, 8] 1 2
9. [1, 2, 3, 4, 5, 6, 7, 8] 2 3
10. [1, 2, 3, 4, 5, 6, 7, 8] 3 4
11. [1, 2, 3, 4, 5, 6, 7, 8] 4 5
12. [1, 2, 3, 4, 5, 6, 7, 8] 5 6
13. [1, 2, 3, 4, 5, 6, 7, 8] 6 7
정렬 한번 끝

//result
[1, 2, 3, 4, 5, 6, 7, 8]
```

---


#### 피드백은 언제나 환영입니다.


