---
title: "분할과 정복 패턴 (Divide and Conquer Pattern)"
date: "2022-09-27"
tags: ["TIL", "Udemy", "Algorithm", "분할과 정복 패턴", 'Divide and Conquer Pattern']
draft: false
summary: "여러 문제해결 패턴 중 분할과 정복 패턴에 대해 알아보자"
---

&nbsp;

# 1. 분할과 정복 패턴 (Divide and Conquer Pattern)

- 주로 배열이나 문자열 같은 큰 규모의 데이터셋을 처리한다.
- 이진 탐색이나 병합 정렬, 퀵 정렬 등에 사용되는 패턴이다.
- 값을 찾기 위해 배열의 왼쪽에서 시작하여 오른쪽 끝까지 이동하는 것이 아닌 배열을 작은 조각으로 `세분`하여 각 조각들을 `어디로 이동`시킬지 결정하는 작업부터 시작한다.
- 즉, 큰 데이터 덩어리를 작은 조각으로 나누는 거다.

&nbsp;

> e.g. 정수로 이루어진 정렬된 배열과 찾으려는 값이 주어지면 배열에서 해당 값이 있는 인덱스(위치)를 반환하는 search라는 함수를 작성해라. 값을 찾을 수 없으면 -1을 반환한다.

## 일반적인 패턴
- 시간 복잡도 : `O(n)`
- 선형 탐색
- `arr`가 주어진다면 최대 `arr`의 길이만큼 반복해야 한다.

```js
const search = (arr, val) => {
	for(let i = 0; i < arr.length; i++) {
		if(arr[i] === val) {
			return i;
		}
	}
	return -1;
}

search([1,2,3,4,5,6], 4) // 3
```

## 분할과 정복 패턴

- 시간 복잡도 : `Log(n)`
- 이진 탐색
- 배열의 중간 값을 찾고나면 넘겨진 `val`이 속하는 배열을 골라 다시 중간 값을 찾고 `val`이 속한 배열을 골라서 `val`의 위치를 찾아낼 때까지 반복하는 작업

```js
const search = (arr, val) => {
  let min = 0;
  let max = arr.length - 1;

  while (min <= max) {
		// 배열의 중간 인덱스 (소수점 버림)
    let middle = Math.floor((min + max) / 2);

		// 중간 인덱스의 값이 찾으려는 값보다 작으면
		// 찾으려는 값은 중간 인덱스의 값보다 큰 쪽에 속해 있다.
		// 증간 인덱스 보다 낮은 인덱스의 값들은 필요가 없으므로 min 값 갱신
		// e.g. 중간 인덱스의 값 = 3 / val = 4
		// 3이 4보다 작으니 3보다 작은 값들은 필요가 없다.
    if (arr[middle] < val) {
      min = middle + 1;
    } else if (arr[middle] > val) {
		// 중간 인덱스의 값이 찾으려는 값보다 크면
		// 찾으려는 값은 중간 인덱스의 값보다 작은 쪽에 속해 있다.
		// 증간 인덱스 보다 큰 인덱스의 값들은 필요가 없으므로 max 값 갱신
		// e.g. 중간 인덱스의 값 = 7 / val = 4
		// 7이 4보다 크니 7보다 큰 값들은 필요가 없다.
      max = middle - 1;
    } else {
        // 중간 인덱스의 값이 찾으려는 값과 같으면 바로 return
        // e.g. 중간 인덱스의 값 = 4 / val = 4
        // 중간 인덱스의 값이 찾으려는 값과 같으므로 위치 바로 return
      return middle;
    }
  }
  return -1;
};

search([1,2,3,4,5,6], 4) // 3
```

---

#### 피드백은 언제나 환영입니다.