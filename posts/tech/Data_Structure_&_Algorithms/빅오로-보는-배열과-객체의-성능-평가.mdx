---
title: "빅오로 보는 배열과 객체의 성능 평가"
date: "2022-09-22"
tags: ["TIL", "Udemy", "Data Structure", "빅오", 'Big O',"Object", "Array"]
draft: false
summary: "배열과 객체 그리고 내장된 메소드들의 성능은?"
---

# 1. 객체(Object)의 빅오(Big O)

- 객체는 정렬되어 있지 않다.
- 저장, 접근, 제거, 수정의 경우 `O(1)`이 걸린다.
- 탐색은 단순하게 `key`에 접근하는 것이 아닌 `value`를 가져와야하기에 `O(n)`이 걸린다.

    ```js
     const obj = { name: "jack", age: 0 };
    // 'jack' 이라는 값이 어디에 저장되어 있는가를 알기위해서는 모든 `key`값을 돌며 `value`를 체크해야한다.
    ```

- `Object.keys, Object.values, Object.entries` 메소드들의 경우 `O(n)`이 걸린다.
    - 객체를 돌며 다 배열에 담아 반환해야하기 떄문이다.
- `hasOwnProperty`의 경우 `O(1)`이 걸린다.
    - `key`가 있는지 없는지 바로 접근이 가능하기 때문이다.

&nbsp;

# 2. 배열(Array)의 빅오(Big O)

- 배열은 정렬된 데이터이다. 그렇기에 각 값에 인덱스가 붙어있다.

- 접근의 경우 `O(1)`이 걸린다.
    - `index`로 바로 접근하면 되기 때문이다.

- 탐색은 객체와 동일하게 `O(n)`이 걸린다.

- 저장의 경우 어디에 저장하느냐에 따라 빅오가 달라진다.
    - `push`메소드는 배열의 끝에 저장하기 때문에 `O(1)`이 걸린다.
    - `unshift`메소드는 배열의 처음에 저장하기 때문에 `O(n)`이 걸린다.

- 제거의 경우도 어디를 제거하느냐에 따라 빅오가 달라진다.
  - `pop` 메소드는 배열의 끝값을 제거하기 때문에 `O(1)`이 걸린다.
  - `shift`메소드는 배열의 처음값을 제거하기 때문에 `O(n)`이 걸린다.

&nbsp;

## 왜? 같은 저장, 제거인데 다르죠?

- 인덱스 번호의 재배치 때문이다.
- 배열의 끝에 `저장/제거`하는 경우는 끝에 값이 있기 때문에 다른 값들의 인덱스는 변화가 없다.
- 하지만 배열의 처음에 `저장/제거`하는 경우는 그 작업을 수행한 후 나머지 값들의 인덱스를 재배치 해주어야하기 때문이다.

    ```js
    // 기존의 0번 인덱스에 위치한 값은 "A"이지만 shift 호출이후 "B"로 바뀌게 된다.
    // 즉, 0번 인덱스의 값이 제거가 되면 나머지 값들의 인덱스 번호가 하나씩 떙겨져 재배치 된다.
    const arr = ["A", "B", "C", "D"];
    arr[0] // "A"
    arr.shift()
    arr[0] // "B"
    ```

- 비어있는 배열의 경우를 제외하고 `push, pop`메소드는 `shift, unshift`보다 빠르다.
- `push, pop`메소드의 경우`O(1)`이 걸린다.
- `shift, unshift, concat, slice, splice`메소드의 경우 `O(n)`이 걸린다.
- `sort`메소드의 경우 `O(n* log n)`이 걸린다. (추후 포스팅)
- `forEach, map, filter, reduce`메소드의 경우 `O(n)`이 걸린다.


---


#### 피드백은 언제나 환영입니다.