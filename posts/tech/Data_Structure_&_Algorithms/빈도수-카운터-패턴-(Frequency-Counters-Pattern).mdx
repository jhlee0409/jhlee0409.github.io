---
title: "빈도수 카운터 패턴 (Frequency Counters Pattern)"
date: "2022-09-24"
tags: ["TIL", "Udemy", "Algorithm", "빈도수 카운터 패턴", 'Frequency Counters Pattern']
draft: false
summary: "여러 문제해결 패턴 중 빈도수 카운터 패턴에 대해 알아보자"
---

# 1. 빈도수 카운터 패턴 (Frequency Counters Pattern)

- 자바스크립트의 객체를 이용해서 값과 빈도수를 체크한다.
- 두 개의 배열을 객체로 세분화하고 각 배열의 요소들을 분류하고 비교한다.

&nbsp;

> e.g. 2개의 배열을 이용하는 same 함수가 있다. 두번째 배열의 값들은 첫번쨰 배열의 값들의 제곱이다. 각 값들의 빈도 수가 같아야한다.


## 일반적인 패턴 `O(n^2)`

- `for문`과 `indexOf`메소드를 이용한 이중 반복문

```js
const same = (first, second) => {
    // 두 배열의 길이가 다르면 false
    if (first.length !== second.length) return false;
    for (const i in first) {
        // 두번째 배열에 매칭되는 인덱스 찾기
        const correct = second.indexOf(first[i] ** 2);
        // 없으면 false
        if (correct === -1) return false;
        // 있으면 체크 후 제거
        second.splice(correct, 1);
    }
    return true;
  };

same([1, 2, 3, 2], [4, 1, 9, 4])
```

## 빈도  카운터 패턴 `O(n)`

- 이중 반복문을 돌리는 대신 각 배열을 한번씩반 반복문 적용
- 이중 반복문보다 빠르다.
- 두 객체를 사용해서 각 배열 `value`의 빈도수를 체크 (`value`가 각 배열에서 몇 번나왔는지 알 수 있다.)
- 만둘어진 객체의 `key`를 체크하는 반복문을 작성해서 하나의 객체에만 적용시켜주면 됨 (여기서는 `frequencyCounter1`)
```js
const same = (first, second) => {
    if (first.length !== second.length) return false;
    let frequencyCounter1 = {}; // {1: 1, 2: 2, 3: 1}
    let frequencyCounter2 = {}; // {1: 1, 4: 2, 9: 1}
    for (const val of first) {
        // 없으면 1로 있으면 1씩 더함
        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
    }
    for (const val of second) {
        // 없으면 1로 있으면 1씩 더함
        frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
    }
    for (const key in frequencyCounter1) {
        // 매칭되는 key가 있는지 체크
        if (!(key ** 2 in frequencyCounter2)) {
            return false;
        }
        // 해당 key를 이용해서 매칭되눈 value의 빈도수가 같은지 체크
        if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {
            return false;
        }
    }
    return true;
  };

same([1, 2, 3, 2], [4, 1, 9, 4])
```

---

#### 피드백은 언제나 환영입니다.