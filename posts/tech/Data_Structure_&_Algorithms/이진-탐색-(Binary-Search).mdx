---
title: "이진 탐색 (Binary Search)"
date: "2022-10-06"
tags: ["TIL", "Udemy", "Algorithm", "이진 탐색", 'Binary Search']
draft: false
summary: "이진 탐색에 대해 알아보자"
---

&nbsp;

# 이진 탐색 (Binary Search)

- 기본적인 개념은 분할 정복 패턴을 사용한다.
  - 배열의 중간점을 찾고, 중간점을 기준으로 찾으려는 값이 속한 집단을 선택, 값을 찾을 때까지 반복
- 한 번 체크할 때 배열의 탐색해야할 요소들을 절반 줄일 수 있다.
- 조건은 배열이 분류되어 있어야 한다는 것이다
    > e.g. 숫자 : 오름차순, 내림차순, 문자열 : abc순, ㄱㄴㄷ순


&nbsp;

# 이진 탐색의 의사코드 (Pseudocode)

- 정렬된 배열과 `value`를 인자로 받는 함수이다.
- 배열의 시작점을 나타내는 포인터(좌측)와, 배열의 끝을 나타내는 포인터(우측)를 정한다.
- 시작점의 포인터의 값이 끝지점의 포인터보다 크거나 같아질 때까지 연산을 계속한다.
  - 중간점을 찾는다
  - 만약 중간점이 `value`와 같다면 `index`를 리턴한다.
  - `value`보다 중간점이 더 작다면 좌측 포인터의 값을 올린다.
  -` value`보다 중감점이 더 크다면 우측 포인터의 값을 내린다.
  - 원하는 `value`를 찾지 못했다면 `-1`을 리턴한다.

&nbsp;

## 이진 탐색 구현

- 시간 복잡도 : `O(log n)`
- `log 16 = 4`이고 `log 32 = 5`이다.
- `log 16`에서 `16`은 배열의 길이라고 한다면 `4`는 원하는 값을 찾는 작업의 수라고 보면된다.
- 길이가 `16`인 배열에서 중간점을 찾고 원하는 값이 속한 집단을 찾고 이 작업을 `4번`만 반복하면 된다는 뜻이다.
- 배열의 길이가 배로 늘어남에 따라 값을 찾기 위해 찾는 작업을 한 번만 더 하면 되기 때문이다.

```jsx
const binarySearch = (arr, value) => {
    let left = 0;
    let right = arr.length - 1;
    let middle = Math.floor((left + right) / 2);

    while(arr[middle] !== value  && left <= right) {
        if(value > arr[middle]) left = middle + 1;
        else right = middle - 1;
        middle = Math.floor((left + right) / 2);
    }
    return arr[middle] === value ? middle : -1;
}

binarySearch([1,2,3,4,5],2) // 1
binarySearch([1,2,3,4,5],3) // 2
binarySearch([1,2,3,4,5],5) // 4
binarySearch([1,2,3,4,5],6) // -1
```



---

#### 피드백은 언제나 환영입니다.